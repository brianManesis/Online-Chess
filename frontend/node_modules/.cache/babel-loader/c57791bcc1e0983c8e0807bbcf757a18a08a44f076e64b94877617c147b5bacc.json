{"ast":null,"code":"import { PlayerColor, whitePieces, blackPieces } from \"../utils/Constants\";\nexport class ChessBoardModel {\n  constructor() {\n    this.chessBoard = void 0;\n    this.posMap = new Map();\n    this.whitePieces = void 0;\n    this.blackPieces = void 0;\n    this.moveList = [];\n    this.turn = void 0;\n    this.whitePieces = whitePieces;\n    this.blackPieces = blackPieces;\n    console.log(blackPieces, whitePieces);\n    this.chessBoard = [[], [], [], [], [], [], [], []];\n    //this.initBoard();\n    this.turn = PlayerColor.WHITE;\n  }\n\n  // public move(startPos:string, endPos:string){\n  //     const fromSquare = this.getSquareByPos(startPos);\n  //     const toSquare = this.getSquareByPos(endPos);\n\n  //     if(!fromSquare || !toSquare) return false;\n\n  //     let pieceOnFromSquare: PieceModel | undefined = fromSquare.getPiece();\n  //     if(!pieceOnFromSquare) return false;\n\n  //     let pieceColor = pieceOnFromSquare.getColor();\n  //     if(pieceColor !== this.turn) return false;\n  //     if(this.checkmate(pieceColor)) return false;\n  //     if(this.castleMove(fromSquare,toSquare)) return true;\n  //     if(this.queeningMove(fromSquare,toSquare)) return true;\n  //     if(this.enPassant(fromSquare,toSquare)) return true;\n  //     if(!this.validMove(fromSquare,toSquare,pieceColor)) return false;\n\n  //     pieceOnFromSquare.beenMoved = true;\n  //     fromSquare.setPiece(undefined);\n  //     toSquare.setPiece(pieceOnFromSquare);\n  //     this.moveList.push({fromSquare:fromSquare.getPos(),toSquare:toSquare.getPos()});\n  //     this.changeTurn();\n  //     return true;\n  // }\n  // public checkmate(pieceColor:PlayerColor){\n  //     const search = this.searchBoardForPiece(PieceType.KING,pieceColor);\n  //     const king = search.piece as KingModel;\n  //     const kingPos = search.pos;\n  //     if(!king || !kingPos) return false;\n  //     if(!king.kingInCheck(this,kingPos)) return false;\n  // }\n  // public validMove(startSquare:SquareModel, endSquare:SquareModel, playerColor:PlayerColor){\n  //     const pieceMove = startSquare.getPiece();\n  //     if(pieceMove &&\n  //        pieceMove.validMove(this,startSquare,endSquare,playerColor)){\n  //        return true;\n  //     }\n  //     return false;\n  // }\n\n  // public castleMove(startSquare:SquareModel, endSquare:SquareModel){\n  //     const king = startSquare.getPiece() as KingModel;\n  //     let rookSquare = null;\n  //     let newRookSquare = null;\n  //     const endSquarePos = endSquare.getPos();\n\n  //     if(!king || king.getType() !== PieceType.KING) return false;\n  //     if(king.beenMoved) return false;\n  //     if( endSquarePos !== \"c1\" && endSquarePos !== \"g1\" &&\n  //         endSquarePos !== \"c8\" && endSquarePos !== \"g8\") return false;\n  //     const kingColor = king.getColor();\n  //     const row = kingColor === PlayerColor.WHITE? 7:0;\n\n  //     if(endSquarePos.charAt(0) === \"g\"){\n  //         rookSquare = this.chessBoard[row][7];\n  //         if( this.chessBoard[row][6].getPiece() || king.kingInCheck(this,this.chessBoard[row][6].getPos())||\n  //             this.chessBoard[row][5].getPiece() || king.kingInCheck(this,this.chessBoard[row][5].getPos())\n  //         ) return false;\n  //         newRookSquare = this.chessBoard[row][5];\n  //     }\n  //     else{\n  //         rookSquare = this.chessBoard[row][0]; \n  //         if( this.chessBoard[row][3].getPiece() || king.kingInCheck(this,this.chessBoard[row][3].getPos())||\n  //             this.chessBoard[row][2].getPiece() || king.kingInCheck(this,this.chessBoard[row][2].getPos())||\n  //             this.chessBoard[row][1].getPiece() || king.kingInCheck(this,this.chessBoard[row][1].getPos())\n  //         ) return false;\n  //         newRookSquare = this.chessBoard[row][3];\n  //     }\n  //     const rook = rookSquare.getPiece();\n  //     if(!rook || rook.getType() !== PieceType.ROOK) return false;\n  //     if(rook.beenMoved) return false;\n\n  //     rookSquare.setPiece(undefined);\n  //     startSquare.setPiece(undefined);\n  //     newRookSquare.setPiece(rook);\n  //     endSquare.setPiece(king);\n  //     king.beenMoved = true;\n  //     rook.beenMoved = true;\n  //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //     this.changeTurn();\n  //     return true;\n  // }\n  // private queeningMove(startSquare:SquareModel, endSquare:SquareModel){\n  //     const pawn = startSquare.getPiece();\n  //     const endSquarePos = this.posToArrayPos(endSquare.getPos());\n  //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n  //     if(!endSquarePos) return false;\n\n  //     const pawnColor = pawn.getColor();\n  //     let endRow = pawnColor === PlayerColor.WHITE? 0:7;\n  //     let endSquareRow = endSquarePos.i;\n\n  //     if(pawnColor===PlayerColor.WHITE && endSquareRow!==endRow) return false;\n  //     else if(pawnColor===PlayerColor.BLACK && endSquareRow!==endRow) return false;\n\n  //     startSquare.setPiece(undefined);\n  //     endSquare.setPiece(new QueenModel(PieceType.QUEEN,pawnColor));\n  //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //     this.changeTurn();\n  //     return true;\n  // }\n  // private enPassant(startSquare:SquareModel, endSquare:SquareModel){\n  //     const board = this.chessBoard;\n  //     const pawn = startSquare.getPiece();\n  //     const startSquarePos = this.posToArrayPos(startSquare.getPos());\n  //     if(this.moveList.length === 0) return false;\n\n  //     const lastMove = this.getMoveList().slice(-1)[0];\n  //     const pieceLastMovedNewPos = this.posToArrayPos(lastMove.toSquare);\n  //     const pieceLastMovedOldPos = this.posToArrayPos(lastMove.fromSquare);\n\n  //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n  //     if(!startSquarePos) return false;\n  //     if(!pieceLastMovedNewPos || !pieceLastMovedOldPos) return false;\n\n  //     let direction = PawnModel.pawnDirections(pawn.getColor());\n\n  //     const pieceLastMoved = board[pieceLastMovedNewPos.i][pieceLastMovedNewPos.j];\n\n  //     let pieceLeft;\n  //     let pieceRight;\n  //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j-1)){\n  //         pieceLeft = board[startSquarePos.i][startSquarePos.j-1];\n  //     }\n  //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j+1)){\n  //         pieceRight = board[startSquarePos.i][startSquarePos.j+1];\n  //     }\n  //     let pieceLeftTakes = board[startSquarePos.i+direction.takes.left.dy][startSquarePos.j+direction.takes.left.dx];\n  //     let pieceRightTakes = board[startSquarePos.i+direction.takes.right.dy][startSquarePos.j+direction.takes.right.dx];\n  //     let pieceLastMovedDx = Math.abs(pieceLastMovedNewPos.j-pieceLastMovedOldPos.j);\n  //     let pieceLastMovedDy = Math.abs(pieceLastMovedNewPos.i-pieceLastMovedOldPos.i);\n  //     if(pieceLastMoved === pieceLeft && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceLeftTakes){\n  //         startSquare.setPiece(undefined);\n  //         pieceLeft.setPiece(undefined);\n  //         pieceLeftTakes.setPiece(pawn);\n  //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //         this.changeTurn();\n  //         return true;\n  //     }\n  //     if(pieceLastMoved === pieceRight && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceRightTakes){\n  //         startSquare.setPiece(undefined);\n  //         pieceRight.setPiece(undefined);\n  //         pieceRightTakes.setPiece(pawn);\n  //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //         this.changeTurn();\n  //         return true;\n  //     }\n  //     return false;\n  // }\n  // public isKingInCheck(kingColor:PlayerColor): boolean {\n  //     const kingLocation = this.searchBoardForPiece(PieceType.KING, kingColor)\n  //     const kingPos = kingLocation.pos;\n  //     if(!kingPos) return false;\n\n  //     const king = kingLocation.piece as KingModel;\n  //     if(!king) return false;\n\n  //     return king.kingInCheck(this,kingPos);\n  // }\n  // public searchBoardForPiece(pieceType:PieceType,pieceColor:PlayerColor):{pos:string | undefined, piece:PieceModel | undefined}{\n  //     for(let row of this.chessBoard){\n  //         for(let square of row){\n  //             const piece = square.getPiece();\n  //             if(piece && \n  //                piece.getType() === pieceType &&\n  //                piece.getColor() === pieceColor\n  //                ) return {pos: square.getPos(), piece: piece};\n  //         }\n  //     }\n  //     return {pos:undefined, piece:undefined};\n  // }\n  // public searchBoardFromPos(ignorePiece:PieceModel,startPos:string, directions:Object, pieceType:PieceType, callback:Function){\n  //     const board = this.getChessBoard();\n  //     const posArray = this.posToArrayPos(startPos);\n  //     if(!posArray) return false;\n\n  //     for(const [,value] of Object.entries(directions)){\n  //         let i = posArray.i;\n  //         let j = posArray.j;\n\n  //         let result = callback(board,ignorePiece,i,j,value,pieceType);\n  //         if(result) return true;\n  //     }\n\n  //     return false;\n  // }\n  // public findPiece(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n  //     i += direction.dy;\n  //     j += direction.dx;\n  //     if(ChessBoardModel.withinBoard(i,j)){\n  //         const currentPiece = board[i][j].getPiece();\n  //         if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n  //             if( currentPiece.getType() === pieceType ){\n  //                     return true;\n  //             }\n  //             else{\n  //                 return false;\n  //             }\n  //         }else if( currentPiece && \n  //                     currentPiece.getColor() === ignorePiece.getColor() &&\n  //                     currentPiece !== ignorePiece){\n  //             return false;\n  //         }\n  //     }\n  //     return false;\n  // }\n  // public findPieceInDirection(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n  //     let flag = true;\n  //     while(flag){\n  //         i += direction.dy;\n  //         j += direction.dx;\n\n  //         if(ChessBoardModel.withinBoard(i,j)){\n  //             const currentPiece = board[i][j].getPiece();\n  //             if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n  //                 if( currentPiece.getType() === pieceType){\n  //                         return true;\n  //                 }\n  //                 else{\n  //                     flag = false;\n  //                 }\n  //             }else if( currentPiece && \n  //                         currentPiece.getColor() === ignorePiece.getColor() &&\n  //                         currentPiece !== ignorePiece){\n  //                 flag = false;\n  //             }\n  //         }\n  //         else flag = false;\n  //     }       \n  //     return false;  \n  // }\n  // public findPawnAttack(ignorePiece:PieceModel,kingPos:string){\n  //     let pawnDirection = PawnModel.pawnDirections(ignorePiece.getColor());\n  //     const posArray = this.posToArrayPos(kingPos);\n  //     if(!posArray) return false;\n  //     let leftTakes = pawnDirection.takes.left;\n  //     let rightTakes = pawnDirection.takes.right;\n\n  //     return this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,leftTakes,PieceType.PAWN) ||\n  //            this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,rightTakes,PieceType.PAWN)\n  // }\n  // public getChessBoard():Array<Array<SquareModel>>{\n  //     return this.chessBoard;\n  // }\n  // public getMoveList(){\n  //     return this.moveList;\n  // }\n  // public getPosMap():Map<string,{i:number,j:number}>{\n  //     return this.posMap;\n  // }\n  // public posToArrayPos(pos: string){\n  //     return this.posMap.get(pos);\n  // }\n\n  // public getSquareByPos(pos: string){\n  //     let arrayPos = this.posMap.get(pos);\n  //     if(!arrayPos) return null;\n\n  //     let iPos = arrayPos.i;\n  //     let jPos = arrayPos.j;\n  //     const square = this.chessBoard[iPos][jPos];\n  //     if(!square) return null;\n\n  //     return square;\n  // }\n  // public static withinBoard(i:number, j:number){\n  //     return i>=0 &&\n  //            i<BOARD_SIZE &&\n  //            j>=0 &&\n  //            j<BOARD_SIZE;\n  // }\n  // private changeTurn() {\n  //     this.turn = this.turn === PlayerColor.WHITE?\n  //         PlayerColor.BLACK:\n  //         PlayerColor.WHITE;\n  // }\n\n  // private initBoard(){\n  //     let col = ROW_VALUES;\n  //     let row = [...COL_VALUES].reverse();\n  //     let k = 0, n = 0;\n  //     for(let i = 0; i< BOARD_SIZE; i++){\n  //         for(let j = 0; j< BOARD_SIZE; j++){\n\n  //             let pos:string = col[j]+row[i];\n  //             this.posMap.set(pos,{i:i, j:j});\n  //             let color = (j+i+2) % 2 === 0? PlayerColor.WHITE:PlayerColor.BLACK;\n  //             //let piece:PieceModel | undefined = this.genPiece(col[j],row[i]);\n\n  //             if(i===0 || i===1){\n  //                 this.chessBoard[i].push(\n  //                     new SquareModel(color,pos,this.blackPieces[k])\n  //                 );\n  //                 k++;\n  //             }\n  //             else if(i===6 || i===7){\n  //                 this.chessBoard[i].push(\n  //                     new SquareModel(color,pos,this.whitePieces[n])\n  //                 );\n  //                 n++;\n  //             }\n  //             else{\n  //                 this.chessBoard[i].push(\n  //                     new SquareModel(color,pos)\n  //                 );\n  //             }\n  //             // if(piece){\n  //             //     this.chessBoard[i].push(\n  //             //         new SquareModel(color,pos,piece)\n  //             //     );\n  //             // }else{\n  //             //     this.chessBoard[i].push(\n  //             //         new SquareModel(color,pos)\n  //             //     );\n  //             // }\n  //         }\n  //     }\n  // }\n  // // private genPiece(col:string,row:number): PieceModel | undefined{\n  // //     if(row === 2){\n  // //         return new PawnModel(PieceType.PAWN,PlayerColor.WHITE);\n  // //     }\n  // //     else if(row === 7){\n  // //         return new PawnModel(PieceType.PAWN,PlayerColor.BLACK);\n  // //     }\n  // //     else if(row === 1){\n  // //         if(col === 'a' || col === 'h'){\n  // //             return new RookModel(PieceType.ROOK,PlayerColor.WHITE);\n  // //         }\n  // //         else if(col=== 'b' || col === 'g'){\n  // //             return new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE);\n  // //         }\n  // //         else if(col=== 'c' || col === 'f'){\n  // //             return new BishopModel(PieceType.BISHOP, PlayerColor.WHITE);\n  // //         }\n  // //         else if(col === 'd'){\n  // //             return new QueenModel(PieceType.QUEEN, PlayerColor.WHITE);\n  // //         }\n  // //         else{\n  // //             return new KingModel(PieceType.KING, PlayerColor.WHITE);\n  // //         }\n  // //     }\n  // //     else if(row === 8){\n  // //         if(col === 'a' || col === 'h'){\n  // //             return new RookModel(PieceType.ROOK,PlayerColor.BLACK);\n  // //         }\n  // //         else if(col=== 'b' || col === 'g'){\n  // //             return new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK);\n  // //         }\n  // //         else if(col=== 'c' || col ==='f'){\n  // //             return new BishopModel(PieceType.BISHOP, PlayerColor.BLACK);\n  // //         }\n  // //         else if(col === 'd'){\n  // //             return new QueenModel(PieceType.QUEEN, PlayerColor.BLACK);\n  // //         }\n  // //         else{\n  // //             return new KingModel(PieceType.KING, PlayerColor.BLACK);\n  // //         }\n  // //     }\n  // //     else{\n  // //         return undefined;\n  // //     }\n  // // }\n\n  // public clone():ChessBoardModel{\n  //     const clone =Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n  //     clone.chessBoard = this.chessBoard.map((row) =>\n  //         row.map((square) => {\n  //         const clonedSquare = new SquareModel(square.getColor(), square.getPos());\n  //         const piece = square.getPiece();\n  //         if (piece) {\n  //             const clonedPiece = Object.assign(Object.create(Object.getPrototypeOf(piece)), piece)\n  //             clonedSquare.setPiece(clonedPiece);\n  //         }\n  //         return clonedSquare;\n  //         })\n  //     );\n\n  //     clone.posMap = new Map(this.posMap);\n  //     return clone;\n  // }\n}\n//  const whitePieces = [\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.WHITE),\n//     new KingModel(PieceType.KING, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE)\n// ];\n\n//  const blackPieces = [\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.BLACK),\n//     new KingModel(PieceType.KING, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK)\n// ];","map":{"version":3,"names":["PlayerColor","whitePieces","blackPieces","ChessBoardModel","constructor","chessBoard","posMap","Map","moveList","turn","console","log","WHITE"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/ChessBoardModel.ts"],"sourcesContent":["import { ROW_VALUES, COL_VALUES, PlayerColor, PieceType, BOARD_SIZE,whitePieces,blackPieces} from \"../utils/Constants\";\nimport { PieceModel } from \"./pieces/PieceModel\";\nimport { PawnModel } from \"./pieces/PawnModel\";\nimport { RookModel } from \"./pieces/RookModel\";\nimport { KnightModel } from \"./pieces/KnightModel\";\nimport { BishopModel } from \"./pieces/BishopModel\";\nimport { QueenModel } from \"./pieces/QueenModel\";\nimport { KingModel } from \"./pieces/KingModel\";\nimport { SquareModel } from \"./SquareModel\";\n\nexport class ChessBoardModel{\n    private chessBoard: Array<Array<SquareModel>>;\n    private posMap:Map<string,{i:number,j:number}> = new Map();\n    private whitePieces:Array<PieceModel>;\n    private blackPieces:Array<PieceModel>;\n    private moveList:Array<{fromSquare:string, toSquare:string}>=[];\n    public turn:PlayerColor;\n\n    public constructor(){\n        this.whitePieces = whitePieces;\n        this.blackPieces = blackPieces;\n        console.log(blackPieces,whitePieces);\n        this.chessBoard = [[],[],[],[],[],[],[],[]];\n        //this.initBoard();\n        this.turn = PlayerColor.WHITE;\n    }\n\n    // public move(startPos:string, endPos:string){\n    //     const fromSquare = this.getSquareByPos(startPos);\n    //     const toSquare = this.getSquareByPos(endPos);\n\n    //     if(!fromSquare || !toSquare) return false;\n\n    //     let pieceOnFromSquare: PieceModel | undefined = fromSquare.getPiece();\n    //     if(!pieceOnFromSquare) return false;\n\n    //     let pieceColor = pieceOnFromSquare.getColor();\n    //     if(pieceColor !== this.turn) return false;\n    //     if(this.checkmate(pieceColor)) return false;\n    //     if(this.castleMove(fromSquare,toSquare)) return true;\n    //     if(this.queeningMove(fromSquare,toSquare)) return true;\n    //     if(this.enPassant(fromSquare,toSquare)) return true;\n    //     if(!this.validMove(fromSquare,toSquare,pieceColor)) return false;\n\n    //     pieceOnFromSquare.beenMoved = true;\n    //     fromSquare.setPiece(undefined);\n    //     toSquare.setPiece(pieceOnFromSquare);\n    //     this.moveList.push({fromSquare:fromSquare.getPos(),toSquare:toSquare.getPos()});\n    //     this.changeTurn();\n    //     return true;\n    // }\n    // public checkmate(pieceColor:PlayerColor){\n    //     const search = this.searchBoardForPiece(PieceType.KING,pieceColor);\n    //     const king = search.piece as KingModel;\n    //     const kingPos = search.pos;\n    //     if(!king || !kingPos) return false;\n    //     if(!king.kingInCheck(this,kingPos)) return false;\n    // }\n    // public validMove(startSquare:SquareModel, endSquare:SquareModel, playerColor:PlayerColor){\n    //     const pieceMove = startSquare.getPiece();\n    //     if(pieceMove &&\n    //        pieceMove.validMove(this,startSquare,endSquare,playerColor)){\n    //        return true;\n    //     }\n    //     return false;\n    // }\n\n    // public castleMove(startSquare:SquareModel, endSquare:SquareModel){\n    //     const king = startSquare.getPiece() as KingModel;\n    //     let rookSquare = null;\n    //     let newRookSquare = null;\n    //     const endSquarePos = endSquare.getPos();\n\n    //     if(!king || king.getType() !== PieceType.KING) return false;\n    //     if(king.beenMoved) return false;\n    //     if( endSquarePos !== \"c1\" && endSquarePos !== \"g1\" &&\n    //         endSquarePos !== \"c8\" && endSquarePos !== \"g8\") return false;\n    //     const kingColor = king.getColor();\n    //     const row = kingColor === PlayerColor.WHITE? 7:0;\n\n    //     if(endSquarePos.charAt(0) === \"g\"){\n    //         rookSquare = this.chessBoard[row][7];\n    //         if( this.chessBoard[row][6].getPiece() || king.kingInCheck(this,this.chessBoard[row][6].getPos())||\n    //             this.chessBoard[row][5].getPiece() || king.kingInCheck(this,this.chessBoard[row][5].getPos())\n    //         ) return false;\n    //         newRookSquare = this.chessBoard[row][5];\n    //     }\n    //     else{\n    //         rookSquare = this.chessBoard[row][0]; \n    //         if( this.chessBoard[row][3].getPiece() || king.kingInCheck(this,this.chessBoard[row][3].getPos())||\n    //             this.chessBoard[row][2].getPiece() || king.kingInCheck(this,this.chessBoard[row][2].getPos())||\n    //             this.chessBoard[row][1].getPiece() || king.kingInCheck(this,this.chessBoard[row][1].getPos())\n    //         ) return false;\n    //         newRookSquare = this.chessBoard[row][3];\n    //     }\n    //     const rook = rookSquare.getPiece();\n    //     if(!rook || rook.getType() !== PieceType.ROOK) return false;\n    //     if(rook.beenMoved) return false;\n\n    //     rookSquare.setPiece(undefined);\n    //     startSquare.setPiece(undefined);\n    //     newRookSquare.setPiece(rook);\n    //     endSquare.setPiece(king);\n    //     king.beenMoved = true;\n    //     rook.beenMoved = true;\n    //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //     this.changeTurn();\n    //     return true;\n    // }\n    // private queeningMove(startSquare:SquareModel, endSquare:SquareModel){\n    //     const pawn = startSquare.getPiece();\n    //     const endSquarePos = this.posToArrayPos(endSquare.getPos());\n    //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n    //     if(!endSquarePos) return false;\n        \n    //     const pawnColor = pawn.getColor();\n    //     let endRow = pawnColor === PlayerColor.WHITE? 0:7;\n    //     let endSquareRow = endSquarePos.i;\n        \n    //     if(pawnColor===PlayerColor.WHITE && endSquareRow!==endRow) return false;\n    //     else if(pawnColor===PlayerColor.BLACK && endSquareRow!==endRow) return false;\n\n    //     startSquare.setPiece(undefined);\n    //     endSquare.setPiece(new QueenModel(PieceType.QUEEN,pawnColor));\n    //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //     this.changeTurn();\n    //     return true;\n    // }\n    // private enPassant(startSquare:SquareModel, endSquare:SquareModel){\n    //     const board = this.chessBoard;\n    //     const pawn = startSquare.getPiece();\n    //     const startSquarePos = this.posToArrayPos(startSquare.getPos());\n    //     if(this.moveList.length === 0) return false;\n\n    //     const lastMove = this.getMoveList().slice(-1)[0];\n    //     const pieceLastMovedNewPos = this.posToArrayPos(lastMove.toSquare);\n    //     const pieceLastMovedOldPos = this.posToArrayPos(lastMove.fromSquare);\n\n    //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n    //     if(!startSquarePos) return false;\n    //     if(!pieceLastMovedNewPos || !pieceLastMovedOldPos) return false;\n\n    //     let direction = PawnModel.pawnDirections(pawn.getColor());\n        \n    //     const pieceLastMoved = board[pieceLastMovedNewPos.i][pieceLastMovedNewPos.j];\n\n    //     let pieceLeft;\n    //     let pieceRight;\n    //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j-1)){\n    //         pieceLeft = board[startSquarePos.i][startSquarePos.j-1];\n    //     }\n    //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j+1)){\n    //         pieceRight = board[startSquarePos.i][startSquarePos.j+1];\n    //     }\n    //     let pieceLeftTakes = board[startSquarePos.i+direction.takes.left.dy][startSquarePos.j+direction.takes.left.dx];\n    //     let pieceRightTakes = board[startSquarePos.i+direction.takes.right.dy][startSquarePos.j+direction.takes.right.dx];\n    //     let pieceLastMovedDx = Math.abs(pieceLastMovedNewPos.j-pieceLastMovedOldPos.j);\n    //     let pieceLastMovedDy = Math.abs(pieceLastMovedNewPos.i-pieceLastMovedOldPos.i);\n    //     if(pieceLastMoved === pieceLeft && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceLeftTakes){\n    //         startSquare.setPiece(undefined);\n    //         pieceLeft.setPiece(undefined);\n    //         pieceLeftTakes.setPiece(pawn);\n    //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //         this.changeTurn();\n    //         return true;\n    //     }\n    //     if(pieceLastMoved === pieceRight && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceRightTakes){\n    //         startSquare.setPiece(undefined);\n    //         pieceRight.setPiece(undefined);\n    //         pieceRightTakes.setPiece(pawn);\n    //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //         this.changeTurn();\n    //         return true;\n    //     }\n    //     return false;\n    // }\n    // public isKingInCheck(kingColor:PlayerColor): boolean {\n    //     const kingLocation = this.searchBoardForPiece(PieceType.KING, kingColor)\n    //     const kingPos = kingLocation.pos;\n    //     if(!kingPos) return false;\n\n    //     const king = kingLocation.piece as KingModel;\n    //     if(!king) return false;\n\n    //     return king.kingInCheck(this,kingPos);\n    // }\n    // public searchBoardForPiece(pieceType:PieceType,pieceColor:PlayerColor):{pos:string | undefined, piece:PieceModel | undefined}{\n    //     for(let row of this.chessBoard){\n    //         for(let square of row){\n    //             const piece = square.getPiece();\n    //             if(piece && \n    //                piece.getType() === pieceType &&\n    //                piece.getColor() === pieceColor\n    //                ) return {pos: square.getPos(), piece: piece};\n    //         }\n    //     }\n    //     return {pos:undefined, piece:undefined};\n    // }\n    // public searchBoardFromPos(ignorePiece:PieceModel,startPos:string, directions:Object, pieceType:PieceType, callback:Function){\n    //     const board = this.getChessBoard();\n    //     const posArray = this.posToArrayPos(startPos);\n    //     if(!posArray) return false;\n\n    //     for(const [,value] of Object.entries(directions)){\n    //         let i = posArray.i;\n    //         let j = posArray.j;\n\n    //         let result = callback(board,ignorePiece,i,j,value,pieceType);\n    //         if(result) return true;\n    //     }\n\n    //     return false;\n    // }\n    // public findPiece(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n    //     i += direction.dy;\n    //     j += direction.dx;\n    //     if(ChessBoardModel.withinBoard(i,j)){\n    //         const currentPiece = board[i][j].getPiece();\n    //         if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n    //             if( currentPiece.getType() === pieceType ){\n    //                     return true;\n    //             }\n    //             else{\n    //                 return false;\n    //             }\n    //         }else if( currentPiece && \n    //                     currentPiece.getColor() === ignorePiece.getColor() &&\n    //                     currentPiece !== ignorePiece){\n    //             return false;\n    //         }\n    //     }\n    //     return false;\n    // }\n    // public findPieceInDirection(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n    //     let flag = true;\n    //     while(flag){\n    //         i += direction.dy;\n    //         j += direction.dx;\n\n\n    //         if(ChessBoardModel.withinBoard(i,j)){\n    //             const currentPiece = board[i][j].getPiece();\n    //             if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n    //                 if( currentPiece.getType() === pieceType){\n    //                         return true;\n    //                 }\n    //                 else{\n    //                     flag = false;\n    //                 }\n    //             }else if( currentPiece && \n    //                         currentPiece.getColor() === ignorePiece.getColor() &&\n    //                         currentPiece !== ignorePiece){\n    //                 flag = false;\n    //             }\n    //         }\n    //         else flag = false;\n    //     }       \n    //     return false;  \n    // }\n    // public findPawnAttack(ignorePiece:PieceModel,kingPos:string){\n    //     let pawnDirection = PawnModel.pawnDirections(ignorePiece.getColor());\n    //     const posArray = this.posToArrayPos(kingPos);\n    //     if(!posArray) return false;\n    //     let leftTakes = pawnDirection.takes.left;\n    //     let rightTakes = pawnDirection.takes.right;\n\n    //     return this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,leftTakes,PieceType.PAWN) ||\n    //            this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,rightTakes,PieceType.PAWN)\n    // }\n    // public getChessBoard():Array<Array<SquareModel>>{\n    //     return this.chessBoard;\n    // }\n    // public getMoveList(){\n    //     return this.moveList;\n    // }\n    // public getPosMap():Map<string,{i:number,j:number}>{\n    //     return this.posMap;\n    // }\n    // public posToArrayPos(pos: string){\n    //     return this.posMap.get(pos);\n    // }\n\n    // public getSquareByPos(pos: string){\n    //     let arrayPos = this.posMap.get(pos);\n    //     if(!arrayPos) return null;\n\n    //     let iPos = arrayPos.i;\n    //     let jPos = arrayPos.j;\n    //     const square = this.chessBoard[iPos][jPos];\n    //     if(!square) return null;\n\n    //     return square;\n    // }\n    // public static withinBoard(i:number, j:number){\n    //     return i>=0 &&\n    //            i<BOARD_SIZE &&\n    //            j>=0 &&\n    //            j<BOARD_SIZE;\n    // }\n    // private changeTurn() {\n    //     this.turn = this.turn === PlayerColor.WHITE?\n    //         PlayerColor.BLACK:\n    //         PlayerColor.WHITE;\n    // }\n\n    // private initBoard(){\n    //     let col = ROW_VALUES;\n    //     let row = [...COL_VALUES].reverse();\n    //     let k = 0, n = 0;\n    //     for(let i = 0; i< BOARD_SIZE; i++){\n    //         for(let j = 0; j< BOARD_SIZE; j++){\n\n    //             let pos:string = col[j]+row[i];\n    //             this.posMap.set(pos,{i:i, j:j});\n    //             let color = (j+i+2) % 2 === 0? PlayerColor.WHITE:PlayerColor.BLACK;\n    //             //let piece:PieceModel | undefined = this.genPiece(col[j],row[i]);\n                \n    //             if(i===0 || i===1){\n    //                 this.chessBoard[i].push(\n    //                     new SquareModel(color,pos,this.blackPieces[k])\n    //                 );\n    //                 k++;\n    //             }\n    //             else if(i===6 || i===7){\n    //                 this.chessBoard[i].push(\n    //                     new SquareModel(color,pos,this.whitePieces[n])\n    //                 );\n    //                 n++;\n    //             }\n    //             else{\n    //                 this.chessBoard[i].push(\n    //                     new SquareModel(color,pos)\n    //                 );\n    //             }\n    //             // if(piece){\n    //             //     this.chessBoard[i].push(\n    //             //         new SquareModel(color,pos,piece)\n    //             //     );\n    //             // }else{\n    //             //     this.chessBoard[i].push(\n    //             //         new SquareModel(color,pos)\n    //             //     );\n    //             // }\n    //         }\n    //     }\n    // }\n    // // private genPiece(col:string,row:number): PieceModel | undefined{\n    // //     if(row === 2){\n    // //         return new PawnModel(PieceType.PAWN,PlayerColor.WHITE);\n    // //     }\n    // //     else if(row === 7){\n    // //         return new PawnModel(PieceType.PAWN,PlayerColor.BLACK);\n    // //     }\n    // //     else if(row === 1){\n    // //         if(col === 'a' || col === 'h'){\n    // //             return new RookModel(PieceType.ROOK,PlayerColor.WHITE);\n    // //         }\n    // //         else if(col=== 'b' || col === 'g'){\n    // //             return new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE);\n    // //         }\n    // //         else if(col=== 'c' || col === 'f'){\n    // //             return new BishopModel(PieceType.BISHOP, PlayerColor.WHITE);\n    // //         }\n    // //         else if(col === 'd'){\n    // //             return new QueenModel(PieceType.QUEEN, PlayerColor.WHITE);\n    // //         }\n    // //         else{\n    // //             return new KingModel(PieceType.KING, PlayerColor.WHITE);\n    // //         }\n    // //     }\n    // //     else if(row === 8){\n    // //         if(col === 'a' || col === 'h'){\n    // //             return new RookModel(PieceType.ROOK,PlayerColor.BLACK);\n    // //         }\n    // //         else if(col=== 'b' || col === 'g'){\n    // //             return new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK);\n    // //         }\n    // //         else if(col=== 'c' || col ==='f'){\n    // //             return new BishopModel(PieceType.BISHOP, PlayerColor.BLACK);\n    // //         }\n    // //         else if(col === 'd'){\n    // //             return new QueenModel(PieceType.QUEEN, PlayerColor.BLACK);\n    // //         }\n    // //         else{\n    // //             return new KingModel(PieceType.KING, PlayerColor.BLACK);\n    // //         }\n    // //     }\n    // //     else{\n    // //         return undefined;\n    // //     }\n    // // }\n\n    // public clone():ChessBoardModel{\n    //     const clone =Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    //     clone.chessBoard = this.chessBoard.map((row) =>\n    //         row.map((square) => {\n    //         const clonedSquare = new SquareModel(square.getColor(), square.getPos());\n    //         const piece = square.getPiece();\n    //         if (piece) {\n    //             const clonedPiece = Object.assign(Object.create(Object.getPrototypeOf(piece)), piece)\n    //             clonedSquare.setPiece(clonedPiece);\n    //         }\n    //         return clonedSquare;\n    //         })\n    //     );\n\n    //     clone.posMap = new Map(this.posMap);\n    //     return clone;\n    // }\n}\n//  const whitePieces = [\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.WHITE),\n//     new KingModel(PieceType.KING, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE)\n// ];\n\n//  const blackPieces = [\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.BLACK),\n//     new KingModel(PieceType.KING, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK)\n// ];"],"mappings":"AAAA,SAAiCA,WAAW,EAAwBC,WAAW,EAACC,WAAW,QAAO,oBAAoB;AAUtH,OAAO,MAAMC,eAAe;EAQjBC,WAAWA,CAAA,EAAE;IAAA,KAPZC,UAAU;IAAA,KACVC,MAAM,GAAmC,IAAIC,GAAG,CAAC,CAAC;IAAA,KAClDN,WAAW;IAAA,KACXC,WAAW;IAAA,KACXM,QAAQ,GAA6C,EAAE;IAAA,KACxDC,IAAI;IAGP,IAAI,CAACR,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9BQ,OAAO,CAACC,GAAG,CAACT,WAAW,EAACD,WAAW,CAAC;IACpC,IAAI,CAACI,UAAU,GAAG,CAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,CAAC;IAC3C;IACA,IAAI,CAACI,IAAI,GAAGT,WAAW,CAACY,KAAK;EACjC;;EAEA;EACA;EACA;;EAEA;;EAEA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;;EAEA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}