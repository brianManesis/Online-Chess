{"ast":null,"code":"import { PawnModel } from \"./pieces/PawnModel\";\nimport { RookModel } from \"./pieces/RookModel\";\nimport { KnightModel } from \"./pieces/KnightModel\";\nimport { BishopModel } from \"./pieces/BishopModel\";\nimport { QueenModel } from \"./pieces/QueenModel\";\nimport { KingModel } from \"./pieces/KingModel\";\nimport { SquareModel } from \"./SquareModel\";\nimport { ROW_VALUES, COL_VALUES, PlayerColor, PieceType, BOARD_SIZE } from \"../utils/Constants\";\nexport class ChessBoardModel {\n  constructor() {\n    this.chessBoard = void 0;\n    this.posMap = new Map();\n    this.moveList = [];\n    this.turn = void 0;\n    console.log(whitePieces, blackPieces);\n    this.chessBoard = [[], [], [], [], [], [], [], []];\n    this.initBoard();\n    this.turn = PlayerColor.WHITE;\n  }\n  move(startPos, endPos) {\n    const fromSquare = this.getSquareByPos(startPos);\n    const toSquare = this.getSquareByPos(endPos);\n    if (!fromSquare || !toSquare) return false;\n    let pieceOnFromSquare = fromSquare.getPiece();\n    if (!pieceOnFromSquare) return false;\n    let pieceColor = pieceOnFromSquare.getColor();\n    if (pieceColor !== this.turn) return false;\n    if (this.checkmate(pieceColor)) return false;\n    if (this.castleMove(fromSquare, toSquare)) return true;\n    if (this.queeningMove(fromSquare, toSquare)) return true;\n    if (this.enPassant(fromSquare, toSquare)) return true;\n    if (!this.validMove(fromSquare, toSquare, pieceColor)) return false;\n    pieceOnFromSquare.beenMoved = true;\n    fromSquare.setPiece(undefined);\n    toSquare.setPiece(pieceOnFromSquare);\n    this.moveList.push({\n      fromSquare: fromSquare.getPos(),\n      toSquare: toSquare.getPos()\n    });\n    this.changeTurn();\n    return true;\n  }\n  checkmate(pieceColor) {\n    const search = this.searchBoardForPiece(PieceType.KING, pieceColor);\n    const king = search.piece;\n    const kingPos = search.pos;\n    if (!king || !kingPos) return false;\n    if (!king.kingInCheck(this, kingPos)) return false;\n  }\n  validMove(startSquare, endSquare, playerColor) {\n    const pieceMove = startSquare.getPiece();\n    if (pieceMove && pieceMove.validMove(this, startSquare, endSquare, playerColor)) {\n      return true;\n    }\n    return false;\n  }\n  castleMove(startSquare, endSquare) {\n    const king = startSquare.getPiece();\n    let rookSquare = null;\n    let newRookSquare = null;\n    const endSquarePos = endSquare.getPos();\n    if (!king || king.getType() !== PieceType.KING) return false;\n    if (king.beenMoved) return false;\n    if (endSquarePos !== \"c1\" && endSquarePos !== \"g1\" && endSquarePos !== \"c8\" && endSquarePos !== \"g8\") return false;\n    const kingColor = king.getColor();\n    const row = kingColor === PlayerColor.WHITE ? 7 : 0;\n    if (endSquarePos.charAt(0) === \"g\") {\n      rookSquare = this.chessBoard[row][7];\n      if (this.chessBoard[row][6].getPiece() || king.kingInCheck(this, this.chessBoard[row][6].getPos()) || this.chessBoard[row][5].getPiece() || king.kingInCheck(this, this.chessBoard[row][5].getPos())) return false;\n      newRookSquare = this.chessBoard[row][5];\n    } else {\n      rookSquare = this.chessBoard[row][0];\n      if (this.chessBoard[row][3].getPiece() || king.kingInCheck(this, this.chessBoard[row][3].getPos()) || this.chessBoard[row][2].getPiece() || king.kingInCheck(this, this.chessBoard[row][2].getPos()) || this.chessBoard[row][1].getPiece() || king.kingInCheck(this, this.chessBoard[row][1].getPos())) return false;\n      newRookSquare = this.chessBoard[row][3];\n    }\n    const rook = rookSquare.getPiece();\n    if (!rook || rook.getType() !== PieceType.ROOK) return false;\n    if (rook.beenMoved) return false;\n    rookSquare.setPiece(undefined);\n    startSquare.setPiece(undefined);\n    newRookSquare.setPiece(rook);\n    endSquare.setPiece(king);\n    king.beenMoved = true;\n    rook.beenMoved = true;\n    this.moveList.push({\n      fromSquare: startSquare.getPos(),\n      toSquare: endSquare.getPos()\n    });\n    this.changeTurn();\n    return true;\n  }\n  queeningMove(startSquare, endSquare) {\n    const pawn = startSquare.getPiece();\n    const endSquarePos = this.posToArrayPos(endSquare.getPos());\n    if (!pawn || pawn.getType() !== PieceType.PAWN) return false;\n    if (!endSquarePos) return false;\n    const pawnColor = pawn.getColor();\n    let endRow = pawnColor === PlayerColor.WHITE ? 0 : 7;\n    let endSquareRow = endSquarePos.i;\n    if (pawnColor === PlayerColor.WHITE && endSquareRow !== endRow) return false;else if (pawnColor === PlayerColor.BLACK && endSquareRow !== endRow) return false;\n    startSquare.setPiece(undefined);\n    endSquare.setPiece(new QueenModel(PieceType.QUEEN, pawnColor));\n    this.moveList.push({\n      fromSquare: startSquare.getPos(),\n      toSquare: endSquare.getPos()\n    });\n    this.changeTurn();\n    return true;\n  }\n  enPassant(startSquare, endSquare) {\n    const board = this.chessBoard;\n    const pawn = startSquare.getPiece();\n    const startSquarePos = this.posToArrayPos(startSquare.getPos());\n    if (this.moveList.length === 0) return false;\n    const lastMove = this.getMoveList().slice(-1)[0];\n    const pieceLastMovedNewPos = this.posToArrayPos(lastMove.toSquare);\n    const pieceLastMovedOldPos = this.posToArrayPos(lastMove.fromSquare);\n    if (!pawn || pawn.getType() !== PieceType.PAWN) return false;\n    if (!startSquarePos) return false;\n    if (!pieceLastMovedNewPos || !pieceLastMovedOldPos) return false;\n    let direction = PawnModel.pawnDirections(pawn.getColor());\n    const pieceLastMoved = board[pieceLastMovedNewPos.i][pieceLastMovedNewPos.j];\n    let pieceLeft;\n    let pieceRight;\n    if (ChessBoardModel.withinBoard(startSquarePos.i, startSquarePos.j - 1)) {\n      pieceLeft = board[startSquarePos.i][startSquarePos.j - 1];\n    }\n    if (ChessBoardModel.withinBoard(startSquarePos.i, startSquarePos.j + 1)) {\n      pieceRight = board[startSquarePos.i][startSquarePos.j + 1];\n    }\n    let pieceLeftTakes = board[startSquarePos.i + direction.takes.left.dy][startSquarePos.j + direction.takes.left.dx];\n    let pieceRightTakes = board[startSquarePos.i + direction.takes.right.dy][startSquarePos.j + direction.takes.right.dx];\n    let pieceLastMovedDx = Math.abs(pieceLastMovedNewPos.j - pieceLastMovedOldPos.j);\n    let pieceLastMovedDy = Math.abs(pieceLastMovedNewPos.i - pieceLastMovedOldPos.i);\n    if (pieceLastMoved === pieceLeft && pieceLastMovedDx === 0 && pieceLastMovedDy === 2 && endSquare === pieceLeftTakes) {\n      startSquare.setPiece(undefined);\n      pieceLeft.setPiece(undefined);\n      pieceLeftTakes.setPiece(pawn);\n      this.moveList.push({\n        fromSquare: startSquare.getPos(),\n        toSquare: endSquare.getPos()\n      });\n      this.changeTurn();\n      return true;\n    }\n    if (pieceLastMoved === pieceRight && pieceLastMovedDx === 0 && pieceLastMovedDy === 2 && endSquare === pieceRightTakes) {\n      startSquare.setPiece(undefined);\n      pieceRight.setPiece(undefined);\n      pieceRightTakes.setPiece(pawn);\n      this.moveList.push({\n        fromSquare: startSquare.getPos(),\n        toSquare: endSquare.getPos()\n      });\n      this.changeTurn();\n      return true;\n    }\n    return false;\n  }\n  isKingInCheck(kingColor) {\n    const kingLocation = this.searchBoardForPiece(PieceType.KING, kingColor);\n    const kingPos = kingLocation.pos;\n    if (!kingPos) return false;\n    const king = kingLocation.piece;\n    if (!king) return false;\n    return king.kingInCheck(this, kingPos);\n  }\n  searchBoardForPiece(pieceType, pieceColor) {\n    for (let row of this.chessBoard) {\n      for (let square of row) {\n        const piece = square.getPiece();\n        if (piece && piece.getType() === pieceType && piece.getColor() === pieceColor) return {\n          pos: square.getPos(),\n          piece: piece\n        };\n      }\n    }\n    return {\n      pos: undefined,\n      piece: undefined\n    };\n  }\n  searchBoardFromPos(ignorePiece, startPos, directions, pieceType, callback) {\n    const board = this.getChessBoard();\n    const posArray = this.posToArrayPos(startPos);\n    if (!posArray) return false;\n    for (const [, value] of Object.entries(directions)) {\n      let i = posArray.i;\n      let j = posArray.j;\n      let result = callback(board, ignorePiece, i, j, value, pieceType);\n      if (result) return true;\n    }\n    return false;\n  }\n  findPiece(board, ignorePiece, i, j, direction, pieceType) {\n    i += direction.dy;\n    j += direction.dx;\n    if (ChessBoardModel.withinBoard(i, j)) {\n      const currentPiece = board[i][j].getPiece();\n      if (currentPiece && currentPiece.getColor() !== ignorePiece.getColor()) {\n        if (currentPiece.getType() === pieceType) {\n          return true;\n        } else {\n          return false;\n        }\n      } else if (currentPiece && currentPiece.getColor() === ignorePiece.getColor() && currentPiece !== ignorePiece) {\n        return false;\n      }\n    }\n    return false;\n  }\n  findPieceInDirection(board, ignorePiece, i, j, direction, pieceType) {\n    let flag = true;\n    while (flag) {\n      i += direction.dy;\n      j += direction.dx;\n      if (ChessBoardModel.withinBoard(i, j)) {\n        const currentPiece = board[i][j].getPiece();\n        if (currentPiece && currentPiece.getColor() !== ignorePiece.getColor()) {\n          if (currentPiece.getType() === pieceType) {\n            return true;\n          } else {\n            flag = false;\n          }\n        } else if (currentPiece && currentPiece.getColor() === ignorePiece.getColor() && currentPiece !== ignorePiece) {\n          flag = false;\n        }\n      } else flag = false;\n    }\n    return false;\n  }\n  findPawnAttack(ignorePiece, kingPos) {\n    let pawnDirection = PawnModel.pawnDirections(ignorePiece.getColor());\n    const posArray = this.posToArrayPos(kingPos);\n    if (!posArray) return false;\n    let leftTakes = pawnDirection.takes.left;\n    let rightTakes = pawnDirection.takes.right;\n    return this.findPiece(this.chessBoard, ignorePiece, posArray.i, posArray.j, leftTakes, PieceType.PAWN) || this.findPiece(this.chessBoard, ignorePiece, posArray.i, posArray.j, rightTakes, PieceType.PAWN);\n  }\n  getChessBoard() {\n    return this.chessBoard;\n  }\n  getMoveList() {\n    return this.moveList;\n  }\n  getPosMap() {\n    return this.posMap;\n  }\n  posToArrayPos(pos) {\n    return this.posMap.get(pos);\n  }\n  getSquareByPos(pos) {\n    let arrayPos = this.posMap.get(pos);\n    if (!arrayPos) return null;\n    let iPos = arrayPos.i;\n    let jPos = arrayPos.j;\n    const square = this.chessBoard[iPos][jPos];\n    if (!square) return null;\n    return square;\n  }\n  static withinBoard(i, j) {\n    return i >= 0 && i < BOARD_SIZE && j >= 0 && j < BOARD_SIZE;\n  }\n  changeTurn() {\n    this.turn = this.turn === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE;\n  }\n  initBoard() {\n    let col = ROW_VALUES;\n    let row = [...COL_VALUES].reverse();\n    let k = 0,\n      n = 0;\n    for (let i = 0; i < BOARD_SIZE; i++) {\n      for (let j = 0; j < BOARD_SIZE; j++) {\n        let pos = col[j] + row[i];\n        this.posMap.set(pos, {\n          i: i,\n          j: j\n        });\n        let color = (j + i + 2) % 2 === 0 ? PlayerColor.WHITE : PlayerColor.BLACK;\n        //let piece:PieceModel | undefined = this.genPiece(col[j],row[i]);\n\n        if (i === 0 || i === 1) {\n          this.chessBoard[i].push(new SquareModel(color, pos, blackPieces[k]));\n          k++;\n        } else if (i === 6 || i === 7) {\n          this.chessBoard[i].push(new SquareModel(color, pos, whitePieces[n]));\n          n++;\n        } else {\n          this.chessBoard[i].push(new SquareModel(color, pos));\n        }\n        // if(piece){\n        //     this.chessBoard[i].push(\n        //         new SquareModel(color,pos,piece)\n        //     );\n        // }else{\n        //     this.chessBoard[i].push(\n        //         new SquareModel(color,pos)\n        //     );\n        // }\n      }\n    }\n  }\n  // private genPiece(col:string,row:number): PieceModel | undefined{\n  //     if(row === 2){\n  //         return new PawnModel(PieceType.PAWN,PlayerColor.WHITE);\n  //     }\n  //     else if(row === 7){\n  //         return new PawnModel(PieceType.PAWN,PlayerColor.BLACK);\n  //     }\n  //     else if(row === 1){\n  //         if(col === 'a' || col === 'h'){\n  //             return new RookModel(PieceType.ROOK,PlayerColor.WHITE);\n  //         }\n  //         else if(col=== 'b' || col === 'g'){\n  //             return new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE);\n  //         }\n  //         else if(col=== 'c' || col === 'f'){\n  //             return new BishopModel(PieceType.BISHOP, PlayerColor.WHITE);\n  //         }\n  //         else if(col === 'd'){\n  //             return new QueenModel(PieceType.QUEEN, PlayerColor.WHITE);\n  //         }\n  //         else{\n  //             return new KingModel(PieceType.KING, PlayerColor.WHITE);\n  //         }\n  //     }\n  //     else if(row === 8){\n  //         if(col === 'a' || col === 'h'){\n  //             return new RookModel(PieceType.ROOK,PlayerColor.BLACK);\n  //         }\n  //         else if(col=== 'b' || col === 'g'){\n  //             return new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK);\n  //         }\n  //         else if(col=== 'c' || col ==='f'){\n  //             return new BishopModel(PieceType.BISHOP, PlayerColor.BLACK);\n  //         }\n  //         else if(col === 'd'){\n  //             return new QueenModel(PieceType.QUEEN, PlayerColor.BLACK);\n  //         }\n  //         else{\n  //             return new KingModel(PieceType.KING, PlayerColor.BLACK);\n  //         }\n  //     }\n  //     else{\n  //         return undefined;\n  //     }\n  // }\n\n  clone() {\n    const clone = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    clone.chessBoard = this.chessBoard.map(row => row.map(square => {\n      const clonedSquare = new SquareModel(square.getColor(), square.getPos());\n      const piece = square.getPiece();\n      if (piece) {\n        const clonedPiece = Object.assign(Object.create(Object.getPrototypeOf(piece)), piece);\n        clonedSquare.setPiece(clonedPiece);\n      }\n      return clonedSquare;\n    }));\n    clone.posMap = new Map(this.posMap);\n    return clone;\n  }\n}\nexport const whitePieces = [new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new PawnModel(PieceType.PAWN, PlayerColor.WHITE), new RookModel(PieceType.ROOK, PlayerColor.WHITE), new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE), new BishopModel(PieceType.BISHOP, PlayerColor.WHITE), new QueenModel(PieceType.QUEEN, PlayerColor.WHITE), new KingModel(PieceType.KING, PlayerColor.WHITE), new BishopModel(PieceType.BISHOP, PlayerColor.WHITE), new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE), new RookModel(PieceType.ROOK, PlayerColor.WHITE)];\nexport const blackPieces = [new RookModel(PieceType.ROOK, PlayerColor.BLACK), new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK), new BishopModel(PieceType.BISHOP, PlayerColor.BLACK), new QueenModel(PieceType.QUEEN, PlayerColor.BLACK), new KingModel(PieceType.KING, PlayerColor.BLACK), new BishopModel(PieceType.BISHOP, PlayerColor.BLACK), new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK), new RookModel(PieceType.ROOK, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK), new PawnModel(PieceType.PAWN, PlayerColor.BLACK)];","map":{"version":3,"names":["PawnModel","RookModel","KnightModel","BishopModel","QueenModel","KingModel","SquareModel","ROW_VALUES","COL_VALUES","PlayerColor","PieceType","BOARD_SIZE","ChessBoardModel","constructor","chessBoard","posMap","Map","moveList","turn","console","log","whitePieces","blackPieces","initBoard","WHITE","move","startPos","endPos","fromSquare","getSquareByPos","toSquare","pieceOnFromSquare","getPiece","pieceColor","getColor","checkmate","castleMove","queeningMove","enPassant","validMove","beenMoved","setPiece","undefined","push","getPos","changeTurn","search","searchBoardForPiece","KING","king","piece","kingPos","pos","kingInCheck","startSquare","endSquare","playerColor","pieceMove","rookSquare","newRookSquare","endSquarePos","getType","kingColor","row","charAt","rook","ROOK","pawn","posToArrayPos","PAWN","pawnColor","endRow","endSquareRow","i","BLACK","QUEEN","board","startSquarePos","length","lastMove","getMoveList","slice","pieceLastMovedNewPos","pieceLastMovedOldPos","direction","pawnDirections","pieceLastMoved","j","pieceLeft","pieceRight","withinBoard","pieceLeftTakes","takes","left","dy","dx","pieceRightTakes","right","pieceLastMovedDx","Math","abs","pieceLastMovedDy","isKingInCheck","kingLocation","pieceType","square","searchBoardFromPos","ignorePiece","directions","callback","getChessBoard","posArray","value","Object","entries","result","findPiece","currentPiece","findPieceInDirection","flag","findPawnAttack","pawnDirection","leftTakes","rightTakes","getPosMap","get","arrayPos","iPos","jPos","col","reverse","k","n","set","color","clone","assign","create","getPrototypeOf","map","clonedSquare","clonedPiece","KNIGHT","BISHOP"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/ChessBoardModel.ts"],"sourcesContent":["import { PieceModel } from \"./pieces/PieceModel\";\nimport { PawnModel } from \"./pieces/PawnModel\";\nimport { RookModel } from \"./pieces/RookModel\";\nimport { KnightModel } from \"./pieces/KnightModel\";\nimport { BishopModel } from \"./pieces/BishopModel\";\nimport { QueenModel } from \"./pieces/QueenModel\";\nimport { KingModel } from \"./pieces/KingModel\";\nimport { SquareModel } from \"./SquareModel\";\nimport { ROW_VALUES, COL_VALUES, PlayerColor, PieceType, BOARD_SIZE} from \"../utils/Constants\";\n\nexport class ChessBoardModel{\n    private chessBoard: Array<Array<SquareModel>>;\n    private posMap:Map<string,{i:number,j:number}> = new Map();\n    private moveList:Array<{fromSquare:string, toSquare:string}>=[];\n    public turn:PlayerColor;\n\n    public constructor(){\n        console.log(whitePieces,blackPieces);\n        this.chessBoard = [[],[],[],[],[],[],[],[]];\n        this.initBoard();\n        this.turn = PlayerColor.WHITE;\n    }\n\n    public move(startPos:string, endPos:string){\n        const fromSquare = this.getSquareByPos(startPos);\n        const toSquare = this.getSquareByPos(endPos);\n\n        if(!fromSquare || !toSquare) return false;\n\n        let pieceOnFromSquare: PieceModel | undefined = fromSquare.getPiece();\n        if(!pieceOnFromSquare) return false;\n\n        let pieceColor = pieceOnFromSquare.getColor();\n        if(pieceColor !== this.turn) return false;\n        if(this.checkmate(pieceColor)) return false;\n        if(this.castleMove(fromSquare,toSquare)) return true;\n        if(this.queeningMove(fromSquare,toSquare)) return true;\n        if(this.enPassant(fromSquare,toSquare)) return true;\n        if(!this.validMove(fromSquare,toSquare,pieceColor)) return false;\n\n        pieceOnFromSquare.beenMoved = true;\n        fromSquare.setPiece(undefined);\n        toSquare.setPiece(pieceOnFromSquare);\n        this.moveList.push({fromSquare:fromSquare.getPos(),toSquare:toSquare.getPos()});\n        this.changeTurn();\n        return true;\n    }\n    public checkmate(pieceColor:PlayerColor){\n        const search = this.searchBoardForPiece(PieceType.KING,pieceColor);\n        const king = search.piece as KingModel;\n        const kingPos = search.pos;\n        if(!king || !kingPos) return false;\n        if(!king.kingInCheck(this,kingPos)) return false;\n    }\n    public validMove(startSquare:SquareModel, endSquare:SquareModel, playerColor:PlayerColor){\n        const pieceMove = startSquare.getPiece();\n        if(pieceMove &&\n           pieceMove.validMove(this,startSquare,endSquare,playerColor)){\n           return true;\n        }\n        return false;\n    }\n\n    public castleMove(startSquare:SquareModel, endSquare:SquareModel){\n        const king = startSquare.getPiece() as KingModel;\n        let rookSquare = null;\n        let newRookSquare = null;\n        const endSquarePos = endSquare.getPos();\n\n        if(!king || king.getType() !== PieceType.KING) return false;\n        if(king.beenMoved) return false;\n        if( endSquarePos !== \"c1\" && endSquarePos !== \"g1\" &&\n            endSquarePos !== \"c8\" && endSquarePos !== \"g8\") return false;\n        const kingColor = king.getColor();\n        const row = kingColor === PlayerColor.WHITE? 7:0;\n\n        if(endSquarePos.charAt(0) === \"g\"){\n            rookSquare = this.chessBoard[row][7];\n            if( this.chessBoard[row][6].getPiece() || king.kingInCheck(this,this.chessBoard[row][6].getPos())||\n                this.chessBoard[row][5].getPiece() || king.kingInCheck(this,this.chessBoard[row][5].getPos())\n            ) return false;\n            newRookSquare = this.chessBoard[row][5];\n        }\n        else{\n            rookSquare = this.chessBoard[row][0]; \n            if( this.chessBoard[row][3].getPiece() || king.kingInCheck(this,this.chessBoard[row][3].getPos())||\n                this.chessBoard[row][2].getPiece() || king.kingInCheck(this,this.chessBoard[row][2].getPos())||\n                this.chessBoard[row][1].getPiece() || king.kingInCheck(this,this.chessBoard[row][1].getPos())\n            ) return false;\n            newRookSquare = this.chessBoard[row][3];\n        }\n        const rook = rookSquare.getPiece();\n        if(!rook || rook.getType() !== PieceType.ROOK) return false;\n        if(rook.beenMoved) return false;\n\n        rookSquare.setPiece(undefined);\n        startSquare.setPiece(undefined);\n        newRookSquare.setPiece(rook);\n        endSquare.setPiece(king);\n        king.beenMoved = true;\n        rook.beenMoved = true;\n        this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n        this.changeTurn();\n        return true;\n    }\n    private queeningMove(startSquare:SquareModel, endSquare:SquareModel){\n        const pawn = startSquare.getPiece();\n        const endSquarePos = this.posToArrayPos(endSquare.getPos());\n        if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n        if(!endSquarePos) return false;\n        \n        const pawnColor = pawn.getColor();\n        let endRow = pawnColor === PlayerColor.WHITE? 0:7;\n        let endSquareRow = endSquarePos.i;\n        \n        if(pawnColor===PlayerColor.WHITE && endSquareRow!==endRow) return false;\n        else if(pawnColor===PlayerColor.BLACK && endSquareRow!==endRow) return false;\n\n        startSquare.setPiece(undefined);\n        endSquare.setPiece(new QueenModel(PieceType.QUEEN,pawnColor));\n        this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n        this.changeTurn();\n        return true;\n    }\n    private enPassant(startSquare:SquareModel, endSquare:SquareModel){\n        const board = this.chessBoard;\n        const pawn = startSquare.getPiece();\n        const startSquarePos = this.posToArrayPos(startSquare.getPos());\n        if(this.moveList.length === 0) return false;\n\n        const lastMove = this.getMoveList().slice(-1)[0];\n        const pieceLastMovedNewPos = this.posToArrayPos(lastMove.toSquare);\n        const pieceLastMovedOldPos = this.posToArrayPos(lastMove.fromSquare);\n\n        if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n        if(!startSquarePos) return false;\n        if(!pieceLastMovedNewPos || !pieceLastMovedOldPos) return false;\n\n        let direction = PawnModel.pawnDirections(pawn.getColor());\n        \n        const pieceLastMoved = board[pieceLastMovedNewPos.i][pieceLastMovedNewPos.j];\n\n        let pieceLeft;\n        let pieceRight;\n        if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j-1)){\n            pieceLeft = board[startSquarePos.i][startSquarePos.j-1];\n        }\n        if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j+1)){\n            pieceRight = board[startSquarePos.i][startSquarePos.j+1];\n        }\n        let pieceLeftTakes = board[startSquarePos.i+direction.takes.left.dy][startSquarePos.j+direction.takes.left.dx];\n        let pieceRightTakes = board[startSquarePos.i+direction.takes.right.dy][startSquarePos.j+direction.takes.right.dx];\n        let pieceLastMovedDx = Math.abs(pieceLastMovedNewPos.j-pieceLastMovedOldPos.j);\n        let pieceLastMovedDy = Math.abs(pieceLastMovedNewPos.i-pieceLastMovedOldPos.i);\n        if(pieceLastMoved === pieceLeft && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceLeftTakes){\n            startSquare.setPiece(undefined);\n            pieceLeft.setPiece(undefined);\n            pieceLeftTakes.setPiece(pawn);\n            this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n            this.changeTurn();\n            return true;\n        }\n        if(pieceLastMoved === pieceRight && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceRightTakes){\n            startSquare.setPiece(undefined);\n            pieceRight.setPiece(undefined);\n            pieceRightTakes.setPiece(pawn);\n            this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n            this.changeTurn();\n            return true;\n        }\n        return false;\n    }\n    public isKingInCheck(kingColor:PlayerColor): boolean {\n        const kingLocation = this.searchBoardForPiece(PieceType.KING, kingColor)\n        const kingPos = kingLocation.pos;\n        if(!kingPos) return false;\n\n        const king = kingLocation.piece as KingModel;\n        if(!king) return false;\n\n        return king.kingInCheck(this,kingPos);\n    }\n    public searchBoardForPiece(pieceType:PieceType,pieceColor:PlayerColor):{pos:string | undefined, piece:PieceModel | undefined}{\n        for(let row of this.chessBoard){\n            for(let square of row){\n                const piece = square.getPiece();\n                if(piece && \n                   piece.getType() === pieceType &&\n                   piece.getColor() === pieceColor\n                   ) return {pos: square.getPos(), piece: piece};\n            }\n        }\n        return {pos:undefined, piece:undefined};\n    }\n    public searchBoardFromPos(ignorePiece:PieceModel,startPos:string, directions:Object, pieceType:PieceType, callback:Function){\n        const board = this.getChessBoard();\n        const posArray = this.posToArrayPos(startPos);\n        if(!posArray) return false;\n\n        for(const [,value] of Object.entries(directions)){\n            let i = posArray.i;\n            let j = posArray.j;\n\n            let result = callback(board,ignorePiece,i,j,value,pieceType);\n            if(result) return true;\n        }\n\n        return false;\n    }\n    public findPiece(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n        i += direction.dy;\n        j += direction.dx;\n        if(ChessBoardModel.withinBoard(i,j)){\n            const currentPiece = board[i][j].getPiece();\n            if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n                if( currentPiece.getType() === pieceType ){\n                        return true;\n                }\n                else{\n                    return false;\n                }\n            }else if( currentPiece && \n                        currentPiece.getColor() === ignorePiece.getColor() &&\n                        currentPiece !== ignorePiece){\n                return false;\n            }\n        }\n        return false;\n    }\n    public findPieceInDirection(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n        let flag = true;\n        while(flag){\n            i += direction.dy;\n            j += direction.dx;\n\n\n            if(ChessBoardModel.withinBoard(i,j)){\n                const currentPiece = board[i][j].getPiece();\n                if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n                    if( currentPiece.getType() === pieceType){\n                            return true;\n                    }\n                    else{\n                        flag = false;\n                    }\n                }else if( currentPiece && \n                            currentPiece.getColor() === ignorePiece.getColor() &&\n                            currentPiece !== ignorePiece){\n                    flag = false;\n                }\n            }\n            else flag = false;\n        }       \n        return false;  \n    }\n    public findPawnAttack(ignorePiece:PieceModel,kingPos:string){\n        let pawnDirection = PawnModel.pawnDirections(ignorePiece.getColor());\n        const posArray = this.posToArrayPos(kingPos);\n        if(!posArray) return false;\n        let leftTakes = pawnDirection.takes.left;\n        let rightTakes = pawnDirection.takes.right;\n\n        return this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,leftTakes,PieceType.PAWN) ||\n               this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,rightTakes,PieceType.PAWN)\n    }\n    public getChessBoard():Array<Array<SquareModel>>{\n        return this.chessBoard;\n    }\n    public getMoveList(){\n        return this.moveList;\n    }\n    public getPosMap():Map<string,{i:number,j:number}>{\n        return this.posMap;\n    }\n    public posToArrayPos(pos: string){\n        return this.posMap.get(pos);\n    }\n\n    public getSquareByPos(pos: string){\n        let arrayPos = this.posMap.get(pos);\n        if(!arrayPos) return null;\n\n        let iPos = arrayPos.i;\n        let jPos = arrayPos.j;\n        const square = this.chessBoard[iPos][jPos];\n        if(!square) return null;\n\n        return square;\n    }\n    public static withinBoard(i:number, j:number){\n        return i>=0 &&\n               i<BOARD_SIZE &&\n               j>=0 &&\n               j<BOARD_SIZE;\n    }\n    private changeTurn() {\n        this.turn = this.turn === PlayerColor.WHITE?\n            PlayerColor.BLACK:\n            PlayerColor.WHITE;\n    }\n\n    private initBoard(){\n        let col = ROW_VALUES;\n        let row = [...COL_VALUES].reverse();\n        let k = 0, n = 0;\n        for(let i = 0; i< BOARD_SIZE; i++){\n            for(let j = 0; j< BOARD_SIZE; j++){\n\n                let pos:string = col[j]+row[i];\n                this.posMap.set(pos,{i:i, j:j});\n                let color = (j+i+2) % 2 === 0? PlayerColor.WHITE:PlayerColor.BLACK;\n                //let piece:PieceModel | undefined = this.genPiece(col[j],row[i]);\n                \n                if(i===0 || i===1){\n                    this.chessBoard[i].push(\n                        new SquareModel(color,pos,blackPieces[k])\n                    );\n                    k++;\n                }\n                else if(i===6 || i===7){\n                    this.chessBoard[i].push(\n                        new SquareModel(color,pos,whitePieces[n])\n                    );\n                    n++;\n                }\n                else{\n                    this.chessBoard[i].push(\n                        new SquareModel(color,pos)\n                    );\n                }\n                // if(piece){\n                //     this.chessBoard[i].push(\n                //         new SquareModel(color,pos,piece)\n                //     );\n                // }else{\n                //     this.chessBoard[i].push(\n                //         new SquareModel(color,pos)\n                //     );\n                // }\n            }\n        }\n    }\n    // private genPiece(col:string,row:number): PieceModel | undefined{\n    //     if(row === 2){\n    //         return new PawnModel(PieceType.PAWN,PlayerColor.WHITE);\n    //     }\n    //     else if(row === 7){\n    //         return new PawnModel(PieceType.PAWN,PlayerColor.BLACK);\n    //     }\n    //     else if(row === 1){\n    //         if(col === 'a' || col === 'h'){\n    //             return new RookModel(PieceType.ROOK,PlayerColor.WHITE);\n    //         }\n    //         else if(col=== 'b' || col === 'g'){\n    //             return new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE);\n    //         }\n    //         else if(col=== 'c' || col === 'f'){\n    //             return new BishopModel(PieceType.BISHOP, PlayerColor.WHITE);\n    //         }\n    //         else if(col === 'd'){\n    //             return new QueenModel(PieceType.QUEEN, PlayerColor.WHITE);\n    //         }\n    //         else{\n    //             return new KingModel(PieceType.KING, PlayerColor.WHITE);\n    //         }\n    //     }\n    //     else if(row === 8){\n    //         if(col === 'a' || col === 'h'){\n    //             return new RookModel(PieceType.ROOK,PlayerColor.BLACK);\n    //         }\n    //         else if(col=== 'b' || col === 'g'){\n    //             return new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK);\n    //         }\n    //         else if(col=== 'c' || col ==='f'){\n    //             return new BishopModel(PieceType.BISHOP, PlayerColor.BLACK);\n    //         }\n    //         else if(col === 'd'){\n    //             return new QueenModel(PieceType.QUEEN, PlayerColor.BLACK);\n    //         }\n    //         else{\n    //             return new KingModel(PieceType.KING, PlayerColor.BLACK);\n    //         }\n    //     }\n    //     else{\n    //         return undefined;\n    //     }\n    // }\n\n    public clone():ChessBoardModel{\n        const clone =Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n        clone.chessBoard = this.chessBoard.map((row) =>\n            row.map((square) => {\n            const clonedSquare = new SquareModel(square.getColor(), square.getPos());\n            const piece = square.getPiece();\n            if (piece) {\n                const clonedPiece = Object.assign(Object.create(Object.getPrototypeOf(piece)), piece)\n                clonedSquare.setPiece(clonedPiece);\n            }\n            return clonedSquare;\n            })\n        );\n\n        clone.posMap = new Map(this.posMap);\n        return clone;\n    }\n}\n\nexport const whitePieces = [\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n    new RookModel(PieceType.ROOK,PlayerColor.WHITE),\n    new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n    new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n    new QueenModel(PieceType.QUEEN, PlayerColor.WHITE),\n    new KingModel(PieceType.KING, PlayerColor.WHITE),\n    new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n    new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n    new RookModel(PieceType.ROOK,PlayerColor.WHITE)\n];\n\nexport const blackPieces = [\n    new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n    new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n    new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n    new QueenModel(PieceType.QUEEN, PlayerColor.BLACK),\n    new KingModel(PieceType.KING, PlayerColor.BLACK),\n    new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n    new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n    new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n    new PawnModel(PieceType.PAWN,PlayerColor.BLACK)\n];"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}