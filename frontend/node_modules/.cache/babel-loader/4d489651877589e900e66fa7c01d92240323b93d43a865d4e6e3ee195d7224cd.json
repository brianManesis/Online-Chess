{"ast":null,"code":"import { pawnDirections } from \"./pieceDirections\";\nexport function possiblePawnMoves(boardModel, square, playerColor) {\n  const pawn = square.getPiece();\n  const possibleMoves = new Set();\n  if (pawn) {\n    const board = boardModel.getChessBoard();\n    const pieceDirections = pawnDirections(pawn);\n    const chessNotation = square.getPos();\n    const posArray = boardModel.posToArrayPos(chessNotation);\n    if (posArray) {\n      let forwardSquare = board[posArray.i + pieceDirections.dy][posArray.j + pieceDirections.dx];\n      let forwardSquarePiece = forwardSquare.getPiece();\n      if (forwardSquarePiece && forwardSquarePiece.getColor() !== playerColor) {\n        possibleMoves.add(forwardSquare.getPos());\n      }\n      let leftTakes = pieceDirections.takes.left;\n      let leftSquare = board[posArray.i + leftTakes.dy][posArray.j + leftTakes.dx];\n      let leftSquarePiece = leftSquare.getPiece();\n      if (leftSquarePiece && leftSquarePiece.getColor() !== playerColor) {\n        possibleMoves.add(leftSquare.getPos());\n      }\n      let rightTakes = pieceDirections.takes.right;\n      let rightSquare = board[posArray.i + rightTakes.dy][posArray.j + rightTakes.dx];\n      let rightSquarePiece = rightSquare.getPiece();\n      if (rightSquarePiece && rightSquarePiece.getColor() !== playerColor) {\n        possibleMoves.add(rightSquare.getPos());\n      }\n    }\n  }\n  return possibleMoves;\n\n  // //need to add way of calculating possible moves depending on playerColor\n  // let pawn = square.getPiece();\n  // let pos = square.getPos();\n  // const direction = pawn?.getColor() == playerColor? 1:-1;\n  // const boundry = playerColor\n  // let col = pos.charAt(0);\n  // let row = parseInt(pos.charAt(1));\n  // let possibleMoves:Set<string> = new Set();\n  // if(pawn && pawn.beenMoved && row < 8){\n  //     possibleMoves.add(col+(row+direction));\n  // }\n  // else if(pawn && !pawn.beenMoved && (row < 8)){\n  //     possibleMoves.add(col+(row+direction));\n  //     console.log(pawn && (!pawn.beenMoved) && (row < 8));\n  //     if(row+2 <= 8){\n  //         possibleMoves.add(col+(row+2*direction));\n  //     }\n  // }\n  // return possibleMoves;\n}","map":{"version":3,"names":["pawnDirections","possiblePawnMoves","boardModel","square","playerColor","pawn","getPiece","possibleMoves","Set","board","getChessBoard","pieceDirections","chessNotation","getPos","posArray","posToArrayPos","forwardSquare","i","dy","j","dx","forwardSquarePiece","getColor","add","leftTakes","takes","left","leftSquare","leftSquarePiece","rightTakes","right","rightSquare","rightSquarePiece"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/PossibleMoves.ts"],"sourcesContent":["import { PlayerColor } from \"../Constants\";\nimport { ChessBoardModel } from \"./ChessBoardModel\";\nimport { SquareModel } from \"./SquareModel\";\nimport { pawnDirections } from \"./pieceDirections\";\n\nexport function possiblePawnMoves(boardModel:ChessBoardModel, square:SquareModel, playerColor:PlayerColor){\n    const pawn = square.getPiece();\n    const possibleMoves = new Set<string>();\n\n    if(pawn){\n        const board = boardModel.getChessBoard();\n        const pieceDirections = pawnDirections(pawn);\n        const chessNotation = square.getPos();\n        const posArray = boardModel.posToArrayPos(chessNotation);\n\n        if(posArray){\n            let forwardSquare = board[posArray.i+pieceDirections.dy][posArray.j+pieceDirections.dx];\n            let forwardSquarePiece = forwardSquare.getPiece();\n            if(forwardSquarePiece && forwardSquarePiece.getColor() !== playerColor){\n                possibleMoves.add(forwardSquare.getPos());\n            }\n            \n            let leftTakes = pieceDirections.takes.left;\n            let leftSquare = board[posArray.i+leftTakes.dy][posArray.j+leftTakes.dx];\n            let leftSquarePiece = leftSquare.getPiece();\n            if(leftSquarePiece && leftSquarePiece.getColor() !== playerColor){\n                possibleMoves.add(leftSquare.getPos());\n            }\n\n            let rightTakes = pieceDirections.takes.right;\n            let rightSquare = board[posArray.i+rightTakes.dy][posArray.j+rightTakes.dx];\n            let rightSquarePiece = rightSquare.getPiece();\n            if(rightSquarePiece && rightSquarePiece.getColor() !== playerColor){\n                possibleMoves.add(rightSquare.getPos());\n            }\n        }\n    }\n    return possibleMoves;\n\n\n    // //need to add way of calculating possible moves depending on playerColor\n    // let pawn = square.getPiece();\n    // let pos = square.getPos();\n    // const direction = pawn?.getColor() == playerColor? 1:-1;\n    // const boundry = playerColor\n    // let col = pos.charAt(0);\n    // let row = parseInt(pos.charAt(1));\n    // let possibleMoves:Set<string> = new Set();\n    // if(pawn && pawn.beenMoved && row < 8){\n    //     possibleMoves.add(col+(row+direction));\n    // }\n    // else if(pawn && !pawn.beenMoved && (row < 8)){\n    //     possibleMoves.add(col+(row+direction));\n    //     console.log(pawn && (!pawn.beenMoved) && (row < 8));\n    //     if(row+2 <= 8){\n    //         possibleMoves.add(col+(row+2*direction));\n    //     }\n    // }\n    // return possibleMoves;\n}"],"mappings":"AAGA,SAASA,cAAc,QAAQ,mBAAmB;AAElD,OAAO,SAASC,iBAAiBA,CAACC,UAA0B,EAAEC,MAAkB,EAAEC,WAAuB,EAAC;EACtG,MAAMC,IAAI,GAAGF,MAAM,CAACG,QAAQ,CAAC,CAAC;EAC9B,MAAMC,aAAa,GAAG,IAAIC,GAAG,CAAS,CAAC;EAEvC,IAAGH,IAAI,EAAC;IACJ,MAAMI,KAAK,GAAGP,UAAU,CAACQ,aAAa,CAAC,CAAC;IACxC,MAAMC,eAAe,GAAGX,cAAc,CAACK,IAAI,CAAC;IAC5C,MAAMO,aAAa,GAAGT,MAAM,CAACU,MAAM,CAAC,CAAC;IACrC,MAAMC,QAAQ,GAAGZ,UAAU,CAACa,aAAa,CAACH,aAAa,CAAC;IAExD,IAAGE,QAAQ,EAAC;MACR,IAAIE,aAAa,GAAGP,KAAK,CAACK,QAAQ,CAACG,CAAC,GAACN,eAAe,CAACO,EAAE,CAAC,CAACJ,QAAQ,CAACK,CAAC,GAACR,eAAe,CAACS,EAAE,CAAC;MACvF,IAAIC,kBAAkB,GAAGL,aAAa,CAACV,QAAQ,CAAC,CAAC;MACjD,IAAGe,kBAAkB,IAAIA,kBAAkB,CAACC,QAAQ,CAAC,CAAC,KAAKlB,WAAW,EAAC;QACnEG,aAAa,CAACgB,GAAG,CAACP,aAAa,CAACH,MAAM,CAAC,CAAC,CAAC;MAC7C;MAEA,IAAIW,SAAS,GAAGb,eAAe,CAACc,KAAK,CAACC,IAAI;MAC1C,IAAIC,UAAU,GAAGlB,KAAK,CAACK,QAAQ,CAACG,CAAC,GAACO,SAAS,CAACN,EAAE,CAAC,CAACJ,QAAQ,CAACK,CAAC,GAACK,SAAS,CAACJ,EAAE,CAAC;MACxE,IAAIQ,eAAe,GAAGD,UAAU,CAACrB,QAAQ,CAAC,CAAC;MAC3C,IAAGsB,eAAe,IAAIA,eAAe,CAACN,QAAQ,CAAC,CAAC,KAAKlB,WAAW,EAAC;QAC7DG,aAAa,CAACgB,GAAG,CAACI,UAAU,CAACd,MAAM,CAAC,CAAC,CAAC;MAC1C;MAEA,IAAIgB,UAAU,GAAGlB,eAAe,CAACc,KAAK,CAACK,KAAK;MAC5C,IAAIC,WAAW,GAAGtB,KAAK,CAACK,QAAQ,CAACG,CAAC,GAACY,UAAU,CAACX,EAAE,CAAC,CAACJ,QAAQ,CAACK,CAAC,GAACU,UAAU,CAACT,EAAE,CAAC;MAC3E,IAAIY,gBAAgB,GAAGD,WAAW,CAACzB,QAAQ,CAAC,CAAC;MAC7C,IAAG0B,gBAAgB,IAAIA,gBAAgB,CAACV,QAAQ,CAAC,CAAC,KAAKlB,WAAW,EAAC;QAC/DG,aAAa,CAACgB,GAAG,CAACQ,WAAW,CAAClB,MAAM,CAAC,CAAC,CAAC;MAC3C;IACJ;EACJ;EACA,OAAON,aAAa;;EAGpB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}