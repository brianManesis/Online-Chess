{"ast":null,"code":"import { ChessBoardModel } from \"../ChessBoardModel\";\nimport { PlayerColor } from \"../../utils/Constants\";\nimport { PieceModel } from \"./PieceModel\";\nexport class PawnModel extends PieceModel {\n  constructor(type, color) {\n    super(type, color);\n  }\n  validMove(boardModel, startSquare, endSquare, playerColor) {\n    const pos = endSquare.getPos();\n    return this.updatePossibleMoves(boardModel, startSquare, playerColor).has(pos);\n  }\n  updatePossibleMoves(boardModel, square, playerColor) {\n    const pawn = square.getPiece();\n    this.possibleMoves.clear();\n    if (pawn) {\n      const board = boardModel.getChessBoard();\n      const pieceDirections = PawnModel.pawnDirections(pawn.getColor());\n      const chessNotation = square.getPos();\n      const posArray = boardModel.posToArrayPos(chessNotation);\n      if (posArray) {\n        let fowardI = posArray.i + pieceDirections.dy;\n        let fowardJ = posArray.j + pieceDirections.dx;\n        if (ChessBoardModel.withinBoard(fowardI, fowardJ)) {\n          let forwardSquare = board[fowardI][fowardJ];\n          let forwardSquarePiece = forwardSquare.getPiece();\n          if (forwardSquarePiece === undefined) {\n            this.possibleMoves.add(forwardSquare.getPos());\n          }\n          if (!pawn.beenMoved && forwardSquarePiece === undefined) {\n            let fowardI = posArray.i + 2 * pieceDirections.dy;\n            let fowardJ = posArray.j + 2 * pieceDirections.dx;\n            if (ChessBoardModel.withinBoard(fowardI, fowardJ)) {\n              let forwardSquare = board[fowardI][fowardJ];\n              let forwardSquarePiece = forwardSquare.getPiece();\n              if (forwardSquarePiece === undefined) {\n                this.possibleMoves.add(forwardSquare.getPos());\n              }\n            }\n          }\n        }\n        let leftTakes = pieceDirections.takes.left;\n        let leftI = posArray.i + leftTakes.dy;\n        let leftJ = posArray.j + leftTakes.dx;\n        if (ChessBoardModel.withinBoard(leftI, leftJ)) {\n          let leftSquare = board[leftI][leftJ];\n          let leftSquarePiece = leftSquare.getPiece();\n          if (leftSquarePiece && leftSquarePiece.getColor() !== playerColor) {\n            this.possibleMoves.add(leftSquare.getPos());\n          }\n        }\n        let rightTakes = pieceDirections.takes.right;\n        let rightI = posArray.i + rightTakes.dy;\n        let rightJ = posArray.j + rightTakes.dx;\n        if (this.withinBoard(rightI, rightJ)) {\n          let rightSquare = board[rightI][rightJ];\n          let rightSquarePiece = rightSquare.getPiece();\n          if (rightSquarePiece && rightSquarePiece.getColor() !== playerColor) {\n            this.possibleMoves.add(rightSquare.getPos());\n          }\n        }\n      }\n    }\n    return this.possibleMoves;\n  }\n  static pawnDirections(playerColor) {\n    return playerColor === PlayerColor.WHITE ? {\n      dx: 0,\n      dy: -1,\n      takes: {\n        left: {\n          dx: -1,\n          dy: -1\n        },\n        right: {\n          dx: 1,\n          dy: -1\n        }\n      }\n    } : {\n      dx: 0,\n      dy: 1,\n      takes: {\n        left: {\n          dx: -1,\n          dy: 1\n        },\n        right: {\n          dx: 1,\n          dy: 1\n        }\n      }\n    };\n  }\n}","map":{"version":3,"names":["ChessBoardModel","PlayerColor","PieceModel","PawnModel","constructor","type","color","validMove","boardModel","startSquare","endSquare","playerColor","pos","getPos","updatePossibleMoves","has","square","pawn","getPiece","possibleMoves","clear","board","getChessBoard","pieceDirections","pawnDirections","getColor","chessNotation","posArray","posToArrayPos","fowardI","i","dy","fowardJ","j","dx","withinBoard","forwardSquare","forwardSquarePiece","undefined","add","beenMoved","leftTakes","takes","left","leftI","leftJ","leftSquare","leftSquarePiece","rightTakes","right","rightI","rightJ","rightSquare","rightSquarePiece","WHITE"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/pieces/PawnModel.ts"],"sourcesContent":["import { ChessBoardModel } from \"../ChessBoardModel\";\nimport { SquareModel } from \"../SquareModel\";\nimport { PlayerColor, PieceType } from \"../../utils/Constants\";\nimport { PieceModel } from \"./PieceModel\";\n\nexport class PawnModel extends PieceModel{\n    public constructor(type: PieceType, color: PlayerColor){\n        super(type, color);\n    }\n    public validMove(boardModel:ChessBoardModel, startSquare:SquareModel,\n                    endSquare:SquareModel, playerColor:PlayerColor): boolean {\n        const pos = endSquare.getPos();\n        return this.updatePossibleMoves(boardModel,startSquare,playerColor).has(pos);    \n    }\n\n    private updatePossibleMoves(boardModel:ChessBoardModel, square:SquareModel, playerColor:PlayerColor):Set<string>{\n        const pawn = square.getPiece();\n        this.possibleMoves.clear();\n\n        if(pawn){\n            const board = boardModel.getChessBoard();\n            const pieceDirections = PawnModel.pawnDirections(pawn.getColor());\n            const chessNotation = square.getPos();\n            const posArray = boardModel.posToArrayPos(chessNotation);\n\n            if(posArray){\n                let fowardI = posArray.i+pieceDirections.dy;\n                let fowardJ = posArray.j+pieceDirections.dx;\n                if(ChessBoardModel.withinBoard(fowardI,fowardJ)){\n                    let forwardSquare = board[fowardI][fowardJ];\n                    let forwardSquarePiece = forwardSquare.getPiece();\n                    if(forwardSquarePiece === undefined){\n                        this.possibleMoves.add(forwardSquare.getPos());\n                    }\n                    if(!pawn.beenMoved && forwardSquarePiece === undefined){\n                        let fowardI = posArray.i+2*pieceDirections.dy;\n                        let fowardJ = posArray.j+2*pieceDirections.dx;\n                        if(ChessBoardModel.withinBoard(fowardI,fowardJ)){\n                            let forwardSquare = board[fowardI][fowardJ];\n                            let forwardSquarePiece = forwardSquare.getPiece();\n                            if(forwardSquarePiece === undefined){\n                                this.possibleMoves.add(forwardSquare.getPos());\n                            }\n                        }\n                    }\n                }\n                \n                let leftTakes = pieceDirections.takes.left;\n                let leftI = posArray.i+leftTakes.dy;\n                let leftJ = posArray.j+leftTakes.dx;\n                if(ChessBoardModel.withinBoard(leftI,leftJ)){\n                    let leftSquare = board[leftI][leftJ];\n                    let leftSquarePiece = leftSquare.getPiece();\n                    if(leftSquarePiece && leftSquarePiece.getColor() !== playerColor){\n                        this.possibleMoves.add(leftSquare.getPos());\n                    }\n                }\n\n                let rightTakes = pieceDirections.takes.right;\n                let rightI = posArray.i+rightTakes.dy;\n                let rightJ = posArray.j+rightTakes.dx;\n                if(this.withinBoard(rightI,rightJ)){\n                    let rightSquare = board[rightI][rightJ];\n                    let rightSquarePiece = rightSquare.getPiece();\n                    if(rightSquarePiece && rightSquarePiece.getColor() !== playerColor){\n                        this.possibleMoves.add(rightSquare.getPos());\n                    }\n                }\n            }\n        }\n        return this.possibleMoves;\n    }\n\n    public static pawnDirections(playerColor:PlayerColor){\n        return playerColor === PlayerColor.WHITE?\n        {\n            dx: 0,\n            dy: -1,\n            takes: {\n                left:{\n                    dx: -1,\n                    dy: -1\n                },\n                right:{\n                    dx: 1,\n                    dy: -1\n                }\n            }\n        }:\n        {\n            dx: 0,\n            dy: 1,\n            takes: {\n                left:{\n                    dx: -1,\n                    dy: 1\n                },\n                right:{\n                    dx: 1,\n                    dy: 1\n                }\n            }\n        }\n    }\n    \n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}