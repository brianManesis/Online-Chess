{"ast":null,"code":"import { PieceType } from \"../../utils/Constants\";\nimport { PieceModel } from \"./PieceModel\";\nimport { ChessBoardModel } from \"../ChessBoardModel\";\nimport { KnightModel } from \"./KnightModel\";\nexport class KingModel extends PieceModel {\n  constructor(type, color) {\n    super(type, color);\n    this.isChecked = void 0;\n    this.isChecked = false;\n  }\n  validMove(boardModel, startSquare, endSquare, playerColor) {\n    const pos = endSquare.getPos();\n    return this.updatePossibleMoves(boardModel, startSquare, playerColor).has(pos);\n  }\n  updatePossibleMoves(boardModel, square, playerColor) {\n    const king = square.getPiece();\n    const board = boardModel.getChessBoard();\n    this.possibleMoves.clear();\n    if (!king) return this.possibleMoves;\n    const kingDirections = KingModel.kingDirections;\n    const chessNotation = square.getPos();\n    const posArray = boardModel.posToArrayPos(chessNotation);\n    if (!posArray) return this.possibleMoves;\n    let i = posArray.i;\n    let j = posArray.j;\n    for (const [key, value] of Object.entries(kingDirections)) {\n      this.checkSquare(board, i, j, value.dx, value.dy, playerColor);\n    }\n    console.log(this.possibleMoves);\n    this.possibleMoves.forEach(element => {\n      if (this.kingWillBeInCheck(boardModel, element)) {\n        this.possibleMoves.delete(element);\n      }\n    });\n    console.log(this.possibleMoves);\n    return this.possibleMoves;\n  }\n  kingWillBeInCheck(boardModel, kingPos) {\n    // let lookForRookAndQueen = boardModel.iterateBoard(kingPos, RookModel.rookDirections, \n    //                  (board: Array<Array<SquareModel>>,i:number,j:number,value:any)=>\n    // {\n    //     let flag = true;\n    //     while(flag){\n    //         i += value.dy;\n    //         j += value.dx;\n    //         if(this.withinBoard(i,j)){\n    //             const currentPiece = board[i][j].getPiece();\n    //             if(currentPiece && currentPiece.getColor() !== this.color){\n    //                 if( currentPiece.getType() == PieceType.QUEEN ||\n    //                     currentPiece.getType() == PieceType.ROOK\n    //                 ){\n    //                         return true;\n    //                 }\n    //                 else{\n    //                     flag = false;\n    //                 }\n    //             }else if( currentPiece && \n    //                       currentPiece.getColor() === this.color &&\n    //                       currentPiece !== this){\n    //                 flag = false;\n    //             }\n    //         }\n    //         else flag = false;\n    //     }       \n    // });\n\n    // let lookForBishopAndQueen = boardModel.iterateBoard(kingPos,BishopModel.bishopDirections,\n    //                         (board: Array<Array<SquareModel>>,i:number,j:number,value:any)=>\n    // {\n    //     let flag = true;\n    //     while(flag){\n    //         i += value.dy;\n    //         j += value.dx;\n    //         if(this.withinBoard(i,j)){\n    //             const currentPiece = board[i][j].getPiece();\n    //             if(currentPiece && currentPiece.getColor() !== this.color){\n    //                 if( currentPiece.getType() == PieceType.QUEEN ||\n    //                     currentPiece.getType() == PieceType.BISHOP\n    //                 ){\n    //                         return true;\n    //                 }\n    //                 else{\n    //                     flag = false;\n    //                 }\n    //             }else if( currentPiece && \n    //                       currentPiece.getColor() === this.color &&\n    //                       currentPiece !== this){\n    //                 flag = false;\n    //             }\n    //         }\n    //         else flag = false;\n    //     }       \n    // });\n    // let lookForQueen = boardModel.searchBoard\n    // (kingPos,\n    //  QueenModel.queenDirections, \n    //  PieceType.QUEEN,\n    //  boardModel.findPieceInDirection\n    // );\n    // let lookForRook = boardModel.searchBoard\n    // (kingPos,\n    //  RookModel.rookDirections, \n    //  PieceType.ROOK,\n    //  boardModel.findPieceInDirection\n    // );\n    // let lookForBishop = boardModel.searchBoard\n    // (kingPos,\n    //  BishopModel.bishopDirections, \n    //  PieceType.BISHOP,\n    //  boardModel.findPieceInDirection\n    // );\n    let lookForKnight = this.searchBoard(boardModel, this, kingPos, KnightModel.knightDirections, PieceType.KNIGHT, findPiece);\n    let lookForKing = this.searchBoard(boardModel, this, kingPos, KingModel.kingDirections, PieceType.KING, findPiece);\n\n    // return lookForQueen || lookForRook || lookForBishop || lookForKnight || lookForKing;\n    return lookForKnight || lookForKing;\n  }\n  searchBoard(boardModel, piece, startPos, directions, pieceType, callback) {\n    const board = boardModel.getChessBoard();\n    const posArray = boardModel.posToArrayPos(startPos);\n    if (!posArray) return false;\n    for (const [key, value] of Object.entries(directions)) {\n      let i = posArray.i;\n      let j = posArray.j;\n      let result = callback(board, piece, i, j, value, pieceType);\n      if (result) return true;\n    }\n    return false;\n  }\n\n  // public findPieceInDirection(board: Array<Array<SquareModel>>,i:number,j:number,direction:any, pieceType:PieceType){\n  //     let flag = true;\n\n  //         while(flag){\n  //             i += direction.dy;\n  //             j += direction.dx;\n\n  //             if(this.withinBoard(i,j)){\n  //                 const currentPiece = board[i][j].getPiece();\n  //                 if(currentPiece && currentPiece.getColor() !== this.color){\n  //                     if( currentPiece.getType() == pieceType){\n  //                             return true;\n  //                     }\n  //                     else{\n  //                         flag = false;\n  //                     }\n  //                 }else if( currentPiece && \n  //                           currentPiece.getColor() === this.color &&\n  //                           currentPiece !== this){\n  //                     flag = false;\n  //                 }\n  //             }\n  //             else flag = false;\n  //         }       \n  //     return false;  \n  // }\n}\nKingModel.kingDirections = {\n  left: {\n    dx: -1,\n    dy: 0\n  },\n  right: {\n    dx: 1,\n    dy: 0\n  },\n  up: {\n    dx: 0,\n    dy: -1\n  },\n  down: {\n    dx: 0,\n    dy: 1\n  },\n  leftUp: {\n    dx: -1,\n    dy: -1\n  },\n  rightUp: {\n    dx: 1,\n    dy: -1\n  },\n  leftDown: {\n    dx: -1,\n    dy: 1\n  },\n  rightDown: {\n    dx: 1,\n    dy: 1\n  }\n};\nfunction findPiece(board, piece, i, j, direction, pieceType) {\n  i += direction.dy;\n  j += direction.dx;\n  if (ChessBoardModel.withinBoard(i, j)) {\n    const currentPiece = board[i][j].getPiece();\n    if (currentPiece && currentPiece.getColor() !== piece.getColor()) {\n      if (currentPiece.getType() == pieceType) {\n        return true;\n      } else {\n        return false;\n      }\n    } else if (currentPiece && currentPiece.getColor() === piece.getColor() && currentPiece !== piece) {\n      return false;\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["PieceType","PieceModel","ChessBoardModel","KnightModel","KingModel","constructor","type","color","isChecked","validMove","boardModel","startSquare","endSquare","playerColor","pos","getPos","updatePossibleMoves","has","square","king","getPiece","board","getChessBoard","possibleMoves","clear","kingDirections","chessNotation","posArray","posToArrayPos","i","j","key","value","Object","entries","checkSquare","dx","dy","console","log","forEach","element","kingWillBeInCheck","delete","kingPos","lookForKnight","searchBoard","knightDirections","KNIGHT","findPiece","lookForKing","KING","piece","startPos","directions","pieceType","callback","result","left","right","up","down","leftUp","rightUp","leftDown","rightDown","direction","withinBoard","currentPiece","getColor","getType"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/pieces/KingModel.ts"],"sourcesContent":["import { PlayerColor, PieceType, BOARD_SIZE } from \"../../utils/Constants\";\nimport { PieceModel } from \"./PieceModel\";\nimport { SquareModel } from \"../SquareModel\";\nimport { ChessBoardModel } from \"../ChessBoardModel\";\nimport { QueenModel } from \"./QueenModel\";\nimport { RookModel } from \"./RookModel\";\nimport { BishopModel } from \"./BishopModel\";\nimport { KnightModel } from \"./KnightModel\";\n\nexport class KingModel extends PieceModel{\n\n    public isChecked:boolean;\n\n    public constructor(type: PieceType, color: PlayerColor){\n        super(type, color);\n        this.isChecked = false;\n    }\n\n    public validMove(boardModel:ChessBoardModel, startSquare:SquareModel,\n        endSquare:SquareModel, playerColor:PlayerColor): boolean {\n            const pos = endSquare.getPos();\n            return this.updatePossibleMoves(boardModel,startSquare,playerColor).has(pos); \n        }\n    \n    private updatePossibleMoves(boardModel:ChessBoardModel, square:SquareModel, playerColor:PlayerColor):Set<string>{\n        const king = square.getPiece();\n        const board = boardModel.getChessBoard();\n        this.possibleMoves.clear();\n\n        if(!king) return this.possibleMoves;\n\n        const kingDirections = KingModel.kingDirections;\n        const chessNotation = square.getPos();\n        const posArray = boardModel.posToArrayPos(chessNotation);\n\n        if(!posArray) return this.possibleMoves;\n\n        let i = posArray.i\n        let j = posArray.j; \n        \n        for(const [key,value] of Object.entries(kingDirections)){\n            this.checkSquare(board,i,j,value.dx,value.dy,playerColor);\n        }\n        console.log(this.possibleMoves)\n\n        this.possibleMoves.forEach(element=>{\n            if(this.kingWillBeInCheck(boardModel,element)){\n                this.possibleMoves.delete(element);\n            }\n        });\n        console.log(this.possibleMoves)\n\n        return this.possibleMoves;\n    }\n    private kingWillBeInCheck(boardModel:ChessBoardModel, kingPos:string){\n\n        // let lookForRookAndQueen = boardModel.iterateBoard(kingPos, RookModel.rookDirections, \n        //                  (board: Array<Array<SquareModel>>,i:number,j:number,value:any)=>\n        // {\n        //     let flag = true;\n        //     while(flag){\n        //         i += value.dy;\n        //         j += value.dx;\n        //         if(this.withinBoard(i,j)){\n        //             const currentPiece = board[i][j].getPiece();\n        //             if(currentPiece && currentPiece.getColor() !== this.color){\n        //                 if( currentPiece.getType() == PieceType.QUEEN ||\n        //                     currentPiece.getType() == PieceType.ROOK\n        //                 ){\n        //                         return true;\n        //                 }\n        //                 else{\n        //                     flag = false;\n        //                 }\n        //             }else if( currentPiece && \n        //                       currentPiece.getColor() === this.color &&\n        //                       currentPiece !== this){\n        //                 flag = false;\n        //             }\n        //         }\n        //         else flag = false;\n        //     }       \n        // });\n\n        // let lookForBishopAndQueen = boardModel.iterateBoard(kingPos,BishopModel.bishopDirections,\n        //                         (board: Array<Array<SquareModel>>,i:number,j:number,value:any)=>\n        // {\n        //     let flag = true;\n        //     while(flag){\n        //         i += value.dy;\n        //         j += value.dx;\n        //         if(this.withinBoard(i,j)){\n        //             const currentPiece = board[i][j].getPiece();\n        //             if(currentPiece && currentPiece.getColor() !== this.color){\n        //                 if( currentPiece.getType() == PieceType.QUEEN ||\n        //                     currentPiece.getType() == PieceType.BISHOP\n        //                 ){\n        //                         return true;\n        //                 }\n        //                 else{\n        //                     flag = false;\n        //                 }\n        //             }else if( currentPiece && \n        //                       currentPiece.getColor() === this.color &&\n        //                       currentPiece !== this){\n        //                 flag = false;\n        //             }\n        //         }\n        //         else flag = false;\n        //     }       \n        // });\n        // let lookForQueen = boardModel.searchBoard\n        // (kingPos,\n        //  QueenModel.queenDirections, \n        //  PieceType.QUEEN,\n        //  boardModel.findPieceInDirection\n        // );\n        // let lookForRook = boardModel.searchBoard\n        // (kingPos,\n        //  RookModel.rookDirections, \n        //  PieceType.ROOK,\n        //  boardModel.findPieceInDirection\n        // );\n        // let lookForBishop = boardModel.searchBoard\n        // (kingPos,\n        //  BishopModel.bishopDirections, \n        //  PieceType.BISHOP,\n        //  boardModel.findPieceInDirection\n        // );\n        let lookForKnight = this.searchBoard\n        (boardModel,\n         this,\n         kingPos,\n         KnightModel.knightDirections,\n         PieceType.KNIGHT,\n         findPiece\n        );\n\n        let lookForKing = this.searchBoard\n        (boardModel,\n         this,\n         kingPos,\n         KingModel.kingDirections, \n         PieceType.KING,\n         findPiece\n         );\n\n       // return lookForQueen || lookForRook || lookForBishop || lookForKnight || lookForKing;\n       return lookForKnight || lookForKing;\n    }\n    public searchBoard(boardModel:ChessBoardModel,piece:PieceModel,startPos:string, directions:Object, pieceType:PieceType, callback:Function){\n        const board = boardModel.getChessBoard();\n        const posArray = boardModel.posToArrayPos(startPos);\n        \n        if(!posArray) return false;\n\n        for(const [key,value] of Object.entries(directions)){\n            let i = posArray.i;\n            let j = posArray.j;\n\n            let result = callback(board,piece,i,j,value,pieceType);\n            if(result) return true;\n        }\n\n        return false;\n    }\n    \n    // public findPieceInDirection(board: Array<Array<SquareModel>>,i:number,j:number,direction:any, pieceType:PieceType){\n    //     let flag = true;\n\n    //         while(flag){\n    //             i += direction.dy;\n    //             j += direction.dx;\n\n\n    //             if(this.withinBoard(i,j)){\n    //                 const currentPiece = board[i][j].getPiece();\n    //                 if(currentPiece && currentPiece.getColor() !== this.color){\n    //                     if( currentPiece.getType() == pieceType){\n    //                             return true;\n    //                     }\n    //                     else{\n    //                         flag = false;\n    //                     }\n    //                 }else if( currentPiece && \n    //                           currentPiece.getColor() === this.color &&\n    //                           currentPiece !== this){\n    //                     flag = false;\n    //                 }\n    //             }\n    //             else flag = false;\n    //         }       \n    //     return false;  \n    // }\n    private static kingDirections = {\n            left:{\n                dx:-1,\n                dy:0\n            },\n            right:{\n                dx:1,\n                dy:0\n            },\n            up:{\n                dx:0,\n                dy:-1\n            },\n            down:{\n                dx:0,\n                dy:1\n            },\n            leftUp:{\n                dx:-1,\n                dy:-1\n            },\n            rightUp:{\n                dx:1,\n                dy:-1\n            },\n            leftDown:{\n                dx:-1,\n                dy:1\n            },\n            rightDown:{\n                dx:1,\n                dy:1\n            }\n    }\n}\n\nfunction findPiece(board: Array<Array<SquareModel>>,piece:PieceModel,i:number,j:number,direction:any, pieceType:PieceType){\n    i += direction.dy;\n    j += direction.dx;\n    if(ChessBoardModel.withinBoard(i,j)){\n        const currentPiece = board[i][j].getPiece();\n        if(currentPiece && currentPiece.getColor() !== piece.getColor()){\n            if( currentPiece.getType() == pieceType ){\n                    return true;\n            }\n            else{\n                return false;\n            }\n        }else if( currentPiece && \n                    currentPiece.getColor() === piece.getColor() &&\n                    currentPiece !== piece){\n            return false;\n        }\n    }\n    return false;\n}"],"mappings":"AAAA,SAAsBA,SAAS,QAAoB,uBAAuB;AAC1E,SAASC,UAAU,QAAQ,cAAc;AAEzC,SAASC,eAAe,QAAQ,oBAAoB;AAIpD,SAASC,WAAW,QAAQ,eAAe;AAE3C,OAAO,MAAMC,SAAS,SAASH,UAAU;EAI9BI,WAAWA,CAACC,IAAe,EAAEC,KAAkB,EAAC;IACnD,KAAK,CAACD,IAAI,EAAEC,KAAK,CAAC;IAAC,KAHhBC,SAAS;IAIZ,IAAI,CAACA,SAAS,GAAG,KAAK;EAC1B;EAEOC,SAASA,CAACC,UAA0B,EAAEC,WAAuB,EAChEC,SAAqB,EAAEC,WAAuB,EAAW;IACrD,MAAMC,GAAG,GAAGF,SAAS,CAACG,MAAM,CAAC,CAAC;IAC9B,OAAO,IAAI,CAACC,mBAAmB,CAACN,UAAU,EAACC,WAAW,EAACE,WAAW,CAAC,CAACI,GAAG,CAACH,GAAG,CAAC;EAChF;EAEIE,mBAAmBA,CAACN,UAA0B,EAAEQ,MAAkB,EAAEL,WAAuB,EAAa;IAC5G,MAAMM,IAAI,GAAGD,MAAM,CAACE,QAAQ,CAAC,CAAC;IAC9B,MAAMC,KAAK,GAAGX,UAAU,CAACY,aAAa,CAAC,CAAC;IACxC,IAAI,CAACC,aAAa,CAACC,KAAK,CAAC,CAAC;IAE1B,IAAG,CAACL,IAAI,EAAE,OAAO,IAAI,CAACI,aAAa;IAEnC,MAAME,cAAc,GAAGrB,SAAS,CAACqB,cAAc;IAC/C,MAAMC,aAAa,GAAGR,MAAM,CAACH,MAAM,CAAC,CAAC;IACrC,MAAMY,QAAQ,GAAGjB,UAAU,CAACkB,aAAa,CAACF,aAAa,CAAC;IAExD,IAAG,CAACC,QAAQ,EAAE,OAAO,IAAI,CAACJ,aAAa;IAEvC,IAAIM,CAAC,GAAGF,QAAQ,CAACE,CAAC;IAClB,IAAIC,CAAC,GAAGH,QAAQ,CAACG,CAAC;IAElB,KAAI,MAAM,CAACC,GAAG,EAACC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACT,cAAc,CAAC,EAAC;MACpD,IAAI,CAACU,WAAW,CAACd,KAAK,EAACQ,CAAC,EAACC,CAAC,EAACE,KAAK,CAACI,EAAE,EAACJ,KAAK,CAACK,EAAE,EAACxB,WAAW,CAAC;IAC7D;IACAyB,OAAO,CAACC,GAAG,CAAC,IAAI,CAAChB,aAAa,CAAC;IAE/B,IAAI,CAACA,aAAa,CAACiB,OAAO,CAACC,OAAO,IAAE;MAChC,IAAG,IAAI,CAACC,iBAAiB,CAAChC,UAAU,EAAC+B,OAAO,CAAC,EAAC;QAC1C,IAAI,CAAClB,aAAa,CAACoB,MAAM,CAACF,OAAO,CAAC;MACtC;IACJ,CAAC,CAAC;IACFH,OAAO,CAACC,GAAG,CAAC,IAAI,CAAChB,aAAa,CAAC;IAE/B,OAAO,IAAI,CAACA,aAAa;EAC7B;EACQmB,iBAAiBA,CAAChC,UAA0B,EAAEkC,OAAc,EAAC;IAEjE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIC,aAAa,GAAG,IAAI,CAACC,WAAW,CACnCpC,UAAU,EACV,IAAI,EACJkC,OAAO,EACPzC,WAAW,CAAC4C,gBAAgB,EAC5B/C,SAAS,CAACgD,MAAM,EAChBC,SACD,CAAC;IAED,IAAIC,WAAW,GAAG,IAAI,CAACJ,WAAW,CACjCpC,UAAU,EACV,IAAI,EACJkC,OAAO,EACPxC,SAAS,CAACqB,cAAc,EACxBzB,SAAS,CAACmD,IAAI,EACdF,SACA,CAAC;;IAEH;IACA,OAAOJ,aAAa,IAAIK,WAAW;EACtC;EACOJ,WAAWA,CAACpC,UAA0B,EAAC0C,KAAgB,EAACC,QAAe,EAAEC,UAAiB,EAAEC,SAAmB,EAAEC,QAAiB,EAAC;IACtI,MAAMnC,KAAK,GAAGX,UAAU,CAACY,aAAa,CAAC,CAAC;IACxC,MAAMK,QAAQ,GAAGjB,UAAU,CAACkB,aAAa,CAACyB,QAAQ,CAAC;IAEnD,IAAG,CAAC1B,QAAQ,EAAE,OAAO,KAAK;IAE1B,KAAI,MAAM,CAACI,GAAG,EAACC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACoB,UAAU,CAAC,EAAC;MAChD,IAAIzB,CAAC,GAAGF,QAAQ,CAACE,CAAC;MAClB,IAAIC,CAAC,GAAGH,QAAQ,CAACG,CAAC;MAElB,IAAI2B,MAAM,GAAGD,QAAQ,CAACnC,KAAK,EAAC+B,KAAK,EAACvB,CAAC,EAACC,CAAC,EAACE,KAAK,EAACuB,SAAS,CAAC;MACtD,IAAGE,MAAM,EAAE,OAAO,IAAI;IAC1B;IAEA,OAAO,KAAK;EAChB;;EAEA;EACA;;EAEA;EACA;EACA;;EAGA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AAmCJ;AA3NarD,SAAS,CAyLHqB,cAAc,GAAG;EACxBiC,IAAI,EAAC;IACDtB,EAAE,EAAC,CAAC,CAAC;IACLC,EAAE,EAAC;EACP,CAAC;EACDsB,KAAK,EAAC;IACFvB,EAAE,EAAC,CAAC;IACJC,EAAE,EAAC;EACP,CAAC;EACDuB,EAAE,EAAC;IACCxB,EAAE,EAAC,CAAC;IACJC,EAAE,EAAC,CAAC;EACR,CAAC;EACDwB,IAAI,EAAC;IACDzB,EAAE,EAAC,CAAC;IACJC,EAAE,EAAC;EACP,CAAC;EACDyB,MAAM,EAAC;IACH1B,EAAE,EAAC,CAAC,CAAC;IACLC,EAAE,EAAC,CAAC;EACR,CAAC;EACD0B,OAAO,EAAC;IACJ3B,EAAE,EAAC,CAAC;IACJC,EAAE,EAAC,CAAC;EACR,CAAC;EACD2B,QAAQ,EAAC;IACL5B,EAAE,EAAC,CAAC,CAAC;IACLC,EAAE,EAAC;EACP,CAAC;EACD4B,SAAS,EAAC;IACN7B,EAAE,EAAC,CAAC;IACJC,EAAE,EAAC;EACP;AACR,CAAC;AAGL,SAASY,SAASA,CAAC5B,KAAgC,EAAC+B,KAAgB,EAACvB,CAAQ,EAACC,CAAQ,EAACoC,SAAa,EAAEX,SAAmB,EAAC;EACtH1B,CAAC,IAAIqC,SAAS,CAAC7B,EAAE;EACjBP,CAAC,IAAIoC,SAAS,CAAC9B,EAAE;EACjB,IAAGlC,eAAe,CAACiE,WAAW,CAACtC,CAAC,EAACC,CAAC,CAAC,EAAC;IAChC,MAAMsC,YAAY,GAAG/C,KAAK,CAACQ,CAAC,CAAC,CAACC,CAAC,CAAC,CAACV,QAAQ,CAAC,CAAC;IAC3C,IAAGgD,YAAY,IAAIA,YAAY,CAACC,QAAQ,CAAC,CAAC,KAAKjB,KAAK,CAACiB,QAAQ,CAAC,CAAC,EAAC;MAC5D,IAAID,YAAY,CAACE,OAAO,CAAC,CAAC,IAAIf,SAAS,EAAE;QACjC,OAAO,IAAI;MACnB,CAAC,MACG;QACA,OAAO,KAAK;MAChB;IACJ,CAAC,MAAK,IAAIa,YAAY,IACVA,YAAY,CAACC,QAAQ,CAAC,CAAC,KAAKjB,KAAK,CAACiB,QAAQ,CAAC,CAAC,IAC5CD,YAAY,KAAKhB,KAAK,EAAC;MAC/B,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,KAAK;AAChB"},"metadata":{},"sourceType":"module","externalDependencies":[]}