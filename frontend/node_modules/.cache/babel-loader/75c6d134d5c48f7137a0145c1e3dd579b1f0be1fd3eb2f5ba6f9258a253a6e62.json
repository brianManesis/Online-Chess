{"ast":null,"code":"import { PlayerColor } from \"../../utils/Constants\";\nimport { PieceModel } from \"./PieceModel\";\nexport class KingModel extends PieceModel {\n  constructor(type, color) {\n    super(type, color);\n  }\n  validMove(boardModel, startSquare, endSquare, playerColor) {\n    const pos = endSquare.getPos();\n    return this.updatePossibleMoves(boardModel, startSquare, playerColor).has(pos);\n  }\n  updatePossibleMoves(boardModel, square, playerColor) {\n    const king = square.getPiece();\n    const board = boardModel.getChessBoard();\n    this.possibleMoves.clear();\n    if (!king) return this.possibleMoves;\n    const kingDirections = KingModel.kingDirections;\n    const chessNotation = square.getPos();\n    const posArray = boardModel.posToArrayPos(chessNotation);\n    if (!posArray) return this.possibleMoves;\n    let i = posArray.i;\n    let j = posArray.j;\n    for (const [key, value] of Object.entries(kingDirections)) {\n      this.checkSquare(board, i, j, value.dx, value.dy, playerColor);\n    }\n    this.possibleMoves.forEach(element => {\n      if (this.kingWillBeInCheck(boardModel, element)) {\n        this.possibleMoves.delete(element);\n      }\n    });\n    console.log(this.possibleMoves);\n    return this.possibleMoves;\n  }\n  kingWillBeInCheck(boardModel, kingPos) {\n    const playerColor = this.getColor();\n    const board = boardModel.getChessBoard();\n    const opponentColor = playerColor === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE;\n    const kingSquare = boardModel.getSquareByPos(kingPos);\n    //check row and column for queen\n    // for (let i = 0; i < BOARD_SIZE; i++) {\n    //     for (let j = 0; j < BOARD_SIZE; j++) {\n    //         const square = board[i][j];\n    //         const piece = square.getPiece();\n\n    //         if (piece && piece.getColor() !== playerColor && kingSquare &&\n    //             boardModel.validMove(square, kingSquare, opponentColor)) {\n    //             return true;\n    //         }\n    //     }\n    // }\n\n    // for (let i = 0; i < BOARD_SIZE; i++) {\n    //     for (let j = 0; j < BOARD_SIZE; j++) {\n    //         const square = board[i][j];\n    //         const piece = square.getPiece();\n    //         if (piece && piece.getColor() !== playerColor) {\n    //             const startSquare = square;\n    //             const endSquare = boardModel.getSquareByPos(kingPos);\n\n    //             if (startSquare && \n    //                 endSquare &&\n    //                 boardModel.validMove(startSquare, endSquare, opponentColor)\n    //                 ){\n    //                 return true;\n    //             }\n    //         }\n    //     }\n    // }\n\n    return false;\n  }\n}\nKingModel.kingDirections = {\n  left: {\n    dx: -1,\n    dy: 0\n  },\n  right: {\n    dx: 1,\n    dy: 0\n  },\n  up: {\n    dx: 0,\n    dy: -1\n  },\n  down: {\n    dx: 0,\n    dy: 1\n  },\n  leftUp: {\n    dx: -1,\n    dy: -1\n  },\n  rightUp: {\n    dx: 1,\n    dy: -1\n  },\n  leftDown: {\n    dx: -1,\n    dy: 1\n  },\n  rightDown: {\n    dx: 1,\n    dy: 1\n  }\n};","map":{"version":3,"names":["PlayerColor","PieceModel","KingModel","constructor","type","color","validMove","boardModel","startSquare","endSquare","playerColor","pos","getPos","updatePossibleMoves","has","square","king","getPiece","board","getChessBoard","possibleMoves","clear","kingDirections","chessNotation","posArray","posToArrayPos","i","j","key","value","Object","entries","checkSquare","dx","dy","forEach","element","kingWillBeInCheck","delete","console","log","kingPos","getColor","opponentColor","WHITE","BLACK","kingSquare","getSquareByPos","left","right","up","down","leftUp","rightUp","leftDown","rightDown"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/pieces/KingModel.ts"],"sourcesContent":["import { PlayerColor, PieceType, BOARD_SIZE } from \"../../utils/Constants\";\nimport { PieceModel } from \"./PieceModel\";\nimport { SquareModel } from \"../SquareModel\";\nimport { ChessBoardModel } from \"../ChessBoardModel\";\n\nexport class KingModel extends PieceModel{\n    public constructor(type: PieceType, color: PlayerColor){\n        super(type, color);\n    }\n\n    public validMove(boardModel:ChessBoardModel, startSquare:SquareModel,\n        endSquare:SquareModel, playerColor:PlayerColor): boolean {\n            const pos = endSquare.getPos();\n            return this.updatePossibleMoves(boardModel,startSquare,playerColor).has(pos); \n        }\n    \n    private updatePossibleMoves(boardModel:ChessBoardModel, square:SquareModel, playerColor:PlayerColor):Set<string>{\n        const king = square.getPiece();\n        const board = boardModel.getChessBoard();\n        this.possibleMoves.clear();\n\n        if(!king) return this.possibleMoves;\n\n        const kingDirections = KingModel.kingDirections;\n        const chessNotation = square.getPos();\n        const posArray = boardModel.posToArrayPos(chessNotation);\n\n        if(!posArray) return this.possibleMoves;\n\n        let i = posArray.i;\n        let j = posArray.j; \n        \n        for(const [key,value] of Object.entries(kingDirections)){\n            this.checkSquare(board,i,j,value.dx,value.dy,playerColor);\n        }\n        this.possibleMoves.forEach(element=>{\n            if(this.kingWillBeInCheck(boardModel,element)){\n                this.possibleMoves.delete(element);\n            }\n        });\n        console.log(this.possibleMoves)\n\n        return this.possibleMoves;\n    }\n    private kingWillBeInCheck(boardModel:ChessBoardModel, kingPos:string){\n        const playerColor = this.getColor();\n        const board = boardModel.getChessBoard();\n        const opponentColor = playerColor === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE;\n        const kingSquare = boardModel.getSquareByPos(kingPos);\n        //check row and column for queen\n        // for (let i = 0; i < BOARD_SIZE; i++) {\n        //     for (let j = 0; j < BOARD_SIZE; j++) {\n        //         const square = board[i][j];\n        //         const piece = square.getPiece();\n                \n        //         if (piece && piece.getColor() !== playerColor && kingSquare &&\n        //             boardModel.validMove(square, kingSquare, opponentColor)) {\n        //             return true;\n        //         }\n        //     }\n        // }\n        \n        // for (let i = 0; i < BOARD_SIZE; i++) {\n        //     for (let j = 0; j < BOARD_SIZE; j++) {\n        //         const square = board[i][j];\n        //         const piece = square.getPiece();\n        //         if (piece && piece.getColor() !== playerColor) {\n        //             const startSquare = square;\n        //             const endSquare = boardModel.getSquareByPos(kingPos);\n\n        //             if (startSquare && \n        //                 endSquare &&\n        //                 boardModel.validMove(startSquare, endSquare, opponentColor)\n        //                 ){\n        //                 return true;\n        //             }\n        //         }\n        //     }\n        // }\n        \n      \n        return false;\n    }\n    private static kingDirections = {\n            left:{\n                dx:-1,\n                dy:0\n            },\n            right:{\n                dx:1,\n                dy:0\n            },\n            up:{\n                dx:0,\n                dy:-1\n            },\n            down:{\n                dx:0,\n                dy:1\n            },\n            leftUp:{\n                dx:-1,\n                dy:-1\n            },\n            rightUp:{\n                dx:1,\n                dy:-1\n            },\n            leftDown:{\n                dx:-1,\n                dy:1\n            },\n            rightDown:{\n                dx:1,\n                dy:1\n            }\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}