{"ast":null,"code":"import { PlayerColor } from \"../../Constants\";\nimport { PieceModel } from \"./PieceModel\";\nexport class PawnModel extends PieceModel {\n  constructor(type, color) {\n    super(type, color);\n  }\n  move() {\n    return \"\";\n  }\n  possiblePawnMoves(boardModel, square, playerColor) {\n    const pawn = square.getPiece();\n    const possibleMoves = new Set();\n    if (pawn) {\n      const board = boardModel.getChessBoard();\n      const pieceDirections = this.pawnDirections(pawn);\n      const chessNotation = square.getPos();\n      const posArray = boardModel.posToArrayPos(chessNotation);\n      if (posArray) {\n        let forwardSquare = board[posArray.i + pieceDirections.dy][posArray.j + pieceDirections.dx];\n        let forwardSquarePiece = forwardSquare.getPiece();\n        if (forwardSquarePiece && forwardSquarePiece.getColor() !== playerColor) {\n          possibleMoves.add(forwardSquare.getPos());\n        }\n        let leftTakes = pieceDirections.takes.left;\n        let leftSquare = board[posArray.i + leftTakes.dy][posArray.j + leftTakes.dx];\n        let leftSquarePiece = leftSquare.getPiece();\n        if (leftSquarePiece && leftSquarePiece.getColor() !== playerColor) {\n          possibleMoves.add(leftSquare.getPos());\n        }\n        let rightTakes = pieceDirections.takes.right;\n        let rightSquare = board[posArray.i + rightTakes.dy][posArray.j + rightTakes.dx];\n        let rightSquarePiece = rightSquare.getPiece();\n        if (rightSquarePiece && rightSquarePiece.getColor() !== playerColor) {\n          possibleMoves.add(rightSquare.getPos());\n        }\n      }\n    }\n    return possibleMoves;\n  }\n  pawnDirections(pawn) {\n    return pawn.getColor() === PlayerColor.WHITE ? {\n      dx: 0,\n      dy: -1,\n      takes: {\n        left: {\n          dx: -1,\n          dy: -1\n        },\n        right: {\n          dx: 1,\n          dy: -1\n        }\n      }\n    } : {\n      dx: 0,\n      dy: 1,\n      takes: {\n        left: {\n          dx: -1,\n          dy: 1\n        },\n        right: {\n          dx: 1,\n          dy: 1\n        }\n      }\n    };\n  }\n}","map":{"version":3,"names":["PlayerColor","PieceModel","PawnModel","constructor","type","color","move","possiblePawnMoves","boardModel","square","playerColor","pawn","getPiece","possibleMoves","Set","board","getChessBoard","pieceDirections","pawnDirections","chessNotation","getPos","posArray","posToArrayPos","forwardSquare","i","dy","j","dx","forwardSquarePiece","getColor","add","leftTakes","takes","left","leftSquare","leftSquarePiece","rightTakes","right","rightSquare","rightSquarePiece","WHITE"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/pieces/PawnModel.ts"],"sourcesContent":["import { ChessBoardModel } from \"../ChessBoardModel\";\nimport { SquareModel } from \"../SquareModel\";\nimport { PlayerColor, PieceType } from \"../../Constants\";\nimport { PieceModel } from \"./PieceModel\";\n\nexport class PawnModel extends PieceModel{\n    public constructor(type: PieceType, color: PlayerColor){\n        super(type, color);\n    }\n\n    public move(): string {\n        return \"\";\n    }\n\n    private possiblePawnMoves(boardModel:ChessBoardModel, square:SquareModel, playerColor:PlayerColor):Set<string>{\n        const pawn = square.getPiece();\n        const possibleMoves = new Set<string>();\n    \n        if(pawn){\n            const board = boardModel.getChessBoard();\n            const pieceDirections = this.pawnDirections(pawn);\n            const chessNotation = square.getPos();\n            const posArray = boardModel.posToArrayPos(chessNotation);\n    \n            if(posArray){\n                let forwardSquare = board[posArray.i+pieceDirections.dy][posArray.j+pieceDirections.dx];\n                let forwardSquarePiece = forwardSquare.getPiece();\n                if(forwardSquarePiece && forwardSquarePiece.getColor() !== playerColor){\n                    possibleMoves.add(forwardSquare.getPos());\n                }\n                \n                let leftTakes = pieceDirections.takes.left;\n                let leftSquare = board[posArray.i+leftTakes.dy][posArray.j+leftTakes.dx];\n                let leftSquarePiece = leftSquare.getPiece();\n                if(leftSquarePiece && leftSquarePiece.getColor() !== playerColor){\n                    possibleMoves.add(leftSquare.getPos());\n                }\n    \n                let rightTakes = pieceDirections.takes.right;\n                let rightSquare = board[posArray.i+rightTakes.dy][posArray.j+rightTakes.dx];\n                let rightSquarePiece = rightSquare.getPiece();\n                if(rightSquarePiece && rightSquarePiece.getColor() !== playerColor){\n                    possibleMoves.add(rightSquare.getPos());\n                }\n            }\n        }\n        return possibleMoves;\n    }\n    private pawnDirections(pawn:PieceModel){\n        return pawn.getColor() === PlayerColor.WHITE?\n        {\n            dx: 0,\n            dy: -1,\n            takes: {\n                left:{\n                    dx: -1,\n                    dy: -1\n                },\n                right:{\n                    dx: 1,\n                    dy: -1\n                }\n            }\n        }:\n        {\n            dx: 0,\n            dy: 1,\n            takes: {\n                left:{\n                    dx: -1,\n                    dy: 1\n                },\n                right:{\n                    dx: 1,\n                    dy: 1\n                }\n            }\n        }\n    }\n    \n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}