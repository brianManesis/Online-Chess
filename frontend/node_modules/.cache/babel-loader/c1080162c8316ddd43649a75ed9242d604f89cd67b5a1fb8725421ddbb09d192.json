{"ast":null,"code":"import { ROW_VALUES, COL_VALUES, PlayerColor, PieceType, BOARD_SIZE, whitePieces, blackPieces } from \"../utils/Constants\";\nimport { PawnModel } from \"./pieces/PawnModel\";\nimport { SquareModel } from \"./SquareModel\";\nexport class ChessBoardModel {\n  constructor() {\n    this.chessBoard = void 0;\n    this.posMap = new Map();\n    this.whitePieces = void 0;\n    this.blackPieces = void 0;\n    this.moveList = [];\n    this.turn = void 0;\n    this.whitePieces = whitePieces;\n    this.blackPieces = blackPieces;\n    console.log(blackPieces, whitePieces);\n    this.chessBoard = [[], [], [], [], [], [], [], []];\n    this.initBoard();\n    this.turn = PlayerColor.WHITE;\n  }\n\n  // public move(startPos:string, endPos:string){\n  //     const fromSquare = this.getSquareByPos(startPos);\n  //     const toSquare = this.getSquareByPos(endPos);\n\n  //     if(!fromSquare || !toSquare) return false;\n\n  //     let pieceOnFromSquare: PieceModel | undefined = fromSquare.getPiece();\n  //     if(!pieceOnFromSquare) return false;\n\n  //     let pieceColor = pieceOnFromSquare.getColor();\n  //     if(pieceColor !== this.turn) return false;\n  //     if(this.checkmate(pieceColor)) return false;\n  //     if(this.castleMove(fromSquare,toSquare)) return true;\n  //     if(this.queeningMove(fromSquare,toSquare)) return true;\n  //     if(this.enPassant(fromSquare,toSquare)) return true;\n  //     if(!this.validMove(fromSquare,toSquare,pieceColor)) return false;\n\n  //     pieceOnFromSquare.beenMoved = true;\n  //     fromSquare.setPiece(undefined);\n  //     toSquare.setPiece(pieceOnFromSquare);\n  //     this.moveList.push({fromSquare:fromSquare.getPos(),toSquare:toSquare.getPos()});\n  //     this.changeTurn();\n  //     return true;\n  // }\n  // public checkmate(pieceColor:PlayerColor){\n  //     const search = this.searchBoardForPiece(PieceType.KING,pieceColor);\n  //     const king = search.piece as KingModel;\n  //     const kingPos = search.pos;\n  //     if(!king || !kingPos) return false;\n  //     if(!king.kingInCheck(this,kingPos)) return false;\n  // }\n  // public validMove(startSquare:SquareModel, endSquare:SquareModel, playerColor:PlayerColor){\n  //     const pieceMove = startSquare.getPiece();\n  //     if(pieceMove &&\n  //        pieceMove.validMove(this,startSquare,endSquare,playerColor)){\n  //        return true;\n  //     }\n  //     return false;\n  // }\n\n  // public castleMove(startSquare:SquareModel, endSquare:SquareModel){\n  //     const king = startSquare.getPiece() as KingModel;\n  //     let rookSquare = null;\n  //     let newRookSquare = null;\n  //     const endSquarePos = endSquare.getPos();\n\n  //     if(!king || king.getType() !== PieceType.KING) return false;\n  //     if(king.beenMoved) return false;\n  //     if( endSquarePos !== \"c1\" && endSquarePos !== \"g1\" &&\n  //         endSquarePos !== \"c8\" && endSquarePos !== \"g8\") return false;\n  //     const kingColor = king.getColor();\n  //     const row = kingColor === PlayerColor.WHITE? 7:0;\n\n  //     if(endSquarePos.charAt(0) === \"g\"){\n  //         rookSquare = this.chessBoard[row][7];\n  //         if( this.chessBoard[row][6].getPiece() || king.kingInCheck(this,this.chessBoard[row][6].getPos())||\n  //             this.chessBoard[row][5].getPiece() || king.kingInCheck(this,this.chessBoard[row][5].getPos())\n  //         ) return false;\n  //         newRookSquare = this.chessBoard[row][5];\n  //     }\n  //     else{\n  //         rookSquare = this.chessBoard[row][0]; \n  //         if( this.chessBoard[row][3].getPiece() || king.kingInCheck(this,this.chessBoard[row][3].getPos())||\n  //             this.chessBoard[row][2].getPiece() || king.kingInCheck(this,this.chessBoard[row][2].getPos())||\n  //             this.chessBoard[row][1].getPiece() || king.kingInCheck(this,this.chessBoard[row][1].getPos())\n  //         ) return false;\n  //         newRookSquare = this.chessBoard[row][3];\n  //     }\n  //     const rook = rookSquare.getPiece();\n  //     if(!rook || rook.getType() !== PieceType.ROOK) return false;\n  //     if(rook.beenMoved) return false;\n\n  //     rookSquare.setPiece(undefined);\n  //     startSquare.setPiece(undefined);\n  //     newRookSquare.setPiece(rook);\n  //     endSquare.setPiece(king);\n  //     king.beenMoved = true;\n  //     rook.beenMoved = true;\n  //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //     this.changeTurn();\n  //     return true;\n  // }\n  // private queeningMove(startSquare:SquareModel, endSquare:SquareModel){\n  //     const pawn = startSquare.getPiece();\n  //     const endSquarePos = this.posToArrayPos(endSquare.getPos());\n  //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n  //     if(!endSquarePos) return false;\n\n  //     const pawnColor = pawn.getColor();\n  //     let endRow = pawnColor === PlayerColor.WHITE? 0:7;\n  //     let endSquareRow = endSquarePos.i;\n\n  //     if(pawnColor===PlayerColor.WHITE && endSquareRow!==endRow) return false;\n  //     else if(pawnColor===PlayerColor.BLACK && endSquareRow!==endRow) return false;\n\n  //     startSquare.setPiece(undefined);\n  //     endSquare.setPiece(new QueenModel(PieceType.QUEEN,pawnColor));\n  //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //     this.changeTurn();\n  //     return true;\n  // }\n  // private enPassant(startSquare:SquareModel, endSquare:SquareModel){\n  //     const board = this.chessBoard;\n  //     const pawn = startSquare.getPiece();\n  //     const startSquarePos = this.posToArrayPos(startSquare.getPos());\n  //     if(this.moveList.length === 0) return false;\n\n  //     const lastMove = this.getMoveList().slice(-1)[0];\n  //     const pieceLastMovedNewPos = this.posToArrayPos(lastMove.toSquare);\n  //     const pieceLastMovedOldPos = this.posToArrayPos(lastMove.fromSquare);\n\n  //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n  //     if(!startSquarePos) return false;\n  //     if(!pieceLastMovedNewPos || !pieceLastMovedOldPos) return false;\n\n  //     let direction = PawnModel.pawnDirections(pawn.getColor());\n\n  //     const pieceLastMoved = board[pieceLastMovedNewPos.i][pieceLastMovedNewPos.j];\n\n  //     let pieceLeft;\n  //     let pieceRight;\n  //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j-1)){\n  //         pieceLeft = board[startSquarePos.i][startSquarePos.j-1];\n  //     }\n  //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j+1)){\n  //         pieceRight = board[startSquarePos.i][startSquarePos.j+1];\n  //     }\n  //     let pieceLeftTakes = board[startSquarePos.i+direction.takes.left.dy][startSquarePos.j+direction.takes.left.dx];\n  //     let pieceRightTakes = board[startSquarePos.i+direction.takes.right.dy][startSquarePos.j+direction.takes.right.dx];\n  //     let pieceLastMovedDx = Math.abs(pieceLastMovedNewPos.j-pieceLastMovedOldPos.j);\n  //     let pieceLastMovedDy = Math.abs(pieceLastMovedNewPos.i-pieceLastMovedOldPos.i);\n  //     if(pieceLastMoved === pieceLeft && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceLeftTakes){\n  //         startSquare.setPiece(undefined);\n  //         pieceLeft.setPiece(undefined);\n  //         pieceLeftTakes.setPiece(pawn);\n  //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //         this.changeTurn();\n  //         return true;\n  //     }\n  //     if(pieceLastMoved === pieceRight && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceRightTakes){\n  //         startSquare.setPiece(undefined);\n  //         pieceRight.setPiece(undefined);\n  //         pieceRightTakes.setPiece(pawn);\n  //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n  //         this.changeTurn();\n  //         return true;\n  //     }\n  //     return false;\n  // }\n  // public isKingInCheck(kingColor:PlayerColor): boolean {\n  //     const kingLocation = this.searchBoardForPiece(PieceType.KING, kingColor)\n  //     const kingPos = kingLocation.pos;\n  //     if(!kingPos) return false;\n\n  //     const king = kingLocation.piece as KingModel;\n  //     if(!king) return false;\n\n  //     return king.kingInCheck(this,kingPos);\n  // }\n  // public searchBoardForPiece(pieceType:PieceType,pieceColor:PlayerColor):{pos:string | undefined, piece:PieceModel | undefined}{\n  //     for(let row of this.chessBoard){\n  //         for(let square of row){\n  //             const piece = square.getPiece();\n  //             if(piece && \n  //                piece.getType() === pieceType &&\n  //                piece.getColor() === pieceColor\n  //                ) return {pos: square.getPos(), piece: piece};\n  //         }\n  //     }\n  //     return {pos:undefined, piece:undefined};\n  // }\n  searchBoardFromPos(ignorePiece, startPos, directions, pieceType, callback) {\n    const board = this.getChessBoard();\n    const posArray = this.posToArrayPos(startPos);\n    if (!posArray) return false;\n    for (const [, value] of Object.entries(directions)) {\n      let i = posArray.i;\n      let j = posArray.j;\n      let result = callback(board, ignorePiece, i, j, value, pieceType);\n      if (result) return true;\n    }\n    return false;\n  }\n  findPiece(board, ignorePiece, i, j, direction, pieceType) {\n    i += direction.dy;\n    j += direction.dx;\n    if (ChessBoardModel.withinBoard(i, j)) {\n      const currentPiece = board[i][j].getPiece();\n      if (currentPiece && currentPiece.getColor() !== ignorePiece.getColor()) {\n        if (currentPiece.getType() === pieceType) {\n          return true;\n        } else {\n          return false;\n        }\n      } else if (currentPiece && currentPiece.getColor() === ignorePiece.getColor() && currentPiece !== ignorePiece) {\n        return false;\n      }\n    }\n    return false;\n  }\n  findPieceInDirection(board, ignorePiece, i, j, direction, pieceType) {\n    let flag = true;\n    while (flag) {\n      i += direction.dy;\n      j += direction.dx;\n      if (ChessBoardModel.withinBoard(i, j)) {\n        const currentPiece = board[i][j].getPiece();\n        if (currentPiece && currentPiece.getColor() !== ignorePiece.getColor()) {\n          if (currentPiece.getType() === pieceType) {\n            return true;\n          } else {\n            flag = false;\n          }\n        } else if (currentPiece && currentPiece.getColor() === ignorePiece.getColor() && currentPiece !== ignorePiece) {\n          flag = false;\n        }\n      } else flag = false;\n    }\n    return false;\n  }\n  findPawnAttack(ignorePiece, kingPos) {\n    let pawnDirection = PawnModel.pawnDirections(ignorePiece.getColor());\n    const posArray = this.posToArrayPos(kingPos);\n    if (!posArray) return false;\n    let leftTakes = pawnDirection.takes.left;\n    let rightTakes = pawnDirection.takes.right;\n    return this.findPiece(this.chessBoard, ignorePiece, posArray.i, posArray.j, leftTakes, PieceType.PAWN) || this.findPiece(this.chessBoard, ignorePiece, posArray.i, posArray.j, rightTakes, PieceType.PAWN);\n  }\n  getChessBoard() {\n    return this.chessBoard;\n  }\n  getMoveList() {\n    return this.moveList;\n  }\n  getPosMap() {\n    return this.posMap;\n  }\n  posToArrayPos(pos) {\n    return this.posMap.get(pos);\n  }\n  getSquareByPos(pos) {\n    let arrayPos = this.posMap.get(pos);\n    if (!arrayPos) return null;\n    let iPos = arrayPos.i;\n    let jPos = arrayPos.j;\n    const square = this.chessBoard[iPos][jPos];\n    if (!square) return null;\n    return square;\n  }\n  static withinBoard(i, j) {\n    return i >= 0 && i < BOARD_SIZE && j >= 0 && j < BOARD_SIZE;\n  }\n  changeTurn() {\n    this.turn = this.turn === PlayerColor.WHITE ? PlayerColor.BLACK : PlayerColor.WHITE;\n  }\n  initBoard() {\n    let col = ROW_VALUES;\n    let row = [...COL_VALUES].reverse();\n    let k = 0,\n      n = 0;\n    for (let i = 0; i < BOARD_SIZE; i++) {\n      for (let j = 0; j < BOARD_SIZE; j++) {\n        let pos = col[j] + row[i];\n        this.posMap.set(pos, {\n          i: i,\n          j: j\n        });\n        let color = (j + i + 2) % 2 === 0 ? PlayerColor.WHITE : PlayerColor.BLACK;\n        //let piece:PieceModel | undefined = this.genPiece(col[j],row[i]);\n\n        if (i === 0 || i === 1) {\n          this.chessBoard[i].push(new SquareModel(color, pos, this.blackPieces[k]));\n          k++;\n        } else if (i === 6 || i === 7) {\n          this.chessBoard[i].push(new SquareModel(color, pos, this.whitePieces[n]));\n          n++;\n        } else {\n          this.chessBoard[i].push(new SquareModel(color, pos));\n        }\n        // if(piece){\n        //     this.chessBoard[i].push(\n        //         new SquareModel(color,pos,piece)\n        //     );\n        // }else{\n        //     this.chessBoard[i].push(\n        //         new SquareModel(color,pos)\n        //     );\n        // }\n      }\n    }\n  }\n  // private genPiece(col:string,row:number): PieceModel | undefined{\n  //     if(row === 2){\n  //         return new PawnModel(PieceType.PAWN,PlayerColor.WHITE);\n  //     }\n  //     else if(row === 7){\n  //         return new PawnModel(PieceType.PAWN,PlayerColor.BLACK);\n  //     }\n  //     else if(row === 1){\n  //         if(col === 'a' || col === 'h'){\n  //             return new RookModel(PieceType.ROOK,PlayerColor.WHITE);\n  //         }\n  //         else if(col=== 'b' || col === 'g'){\n  //             return new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE);\n  //         }\n  //         else if(col=== 'c' || col === 'f'){\n  //             return new BishopModel(PieceType.BISHOP, PlayerColor.WHITE);\n  //         }\n  //         else if(col === 'd'){\n  //             return new QueenModel(PieceType.QUEEN, PlayerColor.WHITE);\n  //         }\n  //         else{\n  //             return new KingModel(PieceType.KING, PlayerColor.WHITE);\n  //         }\n  //     }\n  //     else if(row === 8){\n  //         if(col === 'a' || col === 'h'){\n  //             return new RookModel(PieceType.ROOK,PlayerColor.BLACK);\n  //         }\n  //         else if(col=== 'b' || col === 'g'){\n  //             return new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK);\n  //         }\n  //         else if(col=== 'c' || col ==='f'){\n  //             return new BishopModel(PieceType.BISHOP, PlayerColor.BLACK);\n  //         }\n  //         else if(col === 'd'){\n  //             return new QueenModel(PieceType.QUEEN, PlayerColor.BLACK);\n  //         }\n  //         else{\n  //             return new KingModel(PieceType.KING, PlayerColor.BLACK);\n  //         }\n  //     }\n  //     else{\n  //         return undefined;\n  //     }\n  // }\n\n  clone() {\n    const clone = Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    clone.chessBoard = this.chessBoard.map(row => row.map(square => {\n      const clonedSquare = new SquareModel(square.getColor(), square.getPos());\n      const piece = square.getPiece();\n      if (piece) {\n        const clonedPiece = Object.assign(Object.create(Object.getPrototypeOf(piece)), piece);\n        clonedSquare.setPiece(clonedPiece);\n      }\n      return clonedSquare;\n    }));\n    clone.posMap = new Map(this.posMap);\n    return clone;\n  }\n}\n//  const whitePieces = [\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.WHITE),\n//     new KingModel(PieceType.KING, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE)\n// ];\n\n//  const blackPieces = [\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.BLACK),\n//     new KingModel(PieceType.KING, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK)\n// ];","map":{"version":3,"names":["ROW_VALUES","COL_VALUES","PlayerColor","PieceType","BOARD_SIZE","whitePieces","blackPieces","PawnModel","SquareModel","ChessBoardModel","constructor","chessBoard","posMap","Map","moveList","turn","console","log","initBoard","WHITE","searchBoardFromPos","ignorePiece","startPos","directions","pieceType","callback","board","getChessBoard","posArray","posToArrayPos","value","Object","entries","i","j","result","findPiece","direction","dy","dx","withinBoard","currentPiece","getPiece","getColor","getType","findPieceInDirection","flag","findPawnAttack","kingPos","pawnDirection","pawnDirections","leftTakes","takes","left","rightTakes","right","PAWN","getMoveList","getPosMap","pos","get","getSquareByPos","arrayPos","iPos","jPos","square","changeTurn","BLACK","col","row","reverse","k","n","set","color","push","clone","assign","create","getPrototypeOf","map","clonedSquare","getPos","piece","clonedPiece","setPiece"],"sources":["/home/brian/Desktop/Projects/Chess/frontend/src/model/ChessBoardModel.ts"],"sourcesContent":["import { ROW_VALUES, COL_VALUES, PlayerColor, PieceType, BOARD_SIZE,whitePieces,blackPieces} from \"../utils/Constants\";\nimport { PieceModel } from \"./pieces/PieceModel\";\nimport { PawnModel } from \"./pieces/PawnModel\";\nimport { RookModel } from \"./pieces/RookModel\";\nimport { KnightModel } from \"./pieces/KnightModel\";\nimport { BishopModel } from \"./pieces/BishopModel\";\nimport { QueenModel } from \"./pieces/QueenModel\";\nimport { KingModel } from \"./pieces/KingModel\";\nimport { SquareModel } from \"./SquareModel\";\n\nexport class ChessBoardModel{\n    private chessBoard: Array<Array<SquareModel>>;\n    private posMap:Map<string,{i:number,j:number}> = new Map();\n    private whitePieces:Array<PieceModel>;\n    private blackPieces:Array<PieceModel>;\n    private moveList:Array<{fromSquare:string, toSquare:string}>=[];\n    public turn:PlayerColor;\n\n    public constructor(){\n        this.whitePieces = whitePieces;\n        this.blackPieces = blackPieces;\n        console.log(blackPieces,whitePieces);\n        this.chessBoard = [[],[],[],[],[],[],[],[]];\n        this.initBoard();\n        this.turn = PlayerColor.WHITE;\n    }\n\n    // public move(startPos:string, endPos:string){\n    //     const fromSquare = this.getSquareByPos(startPos);\n    //     const toSquare = this.getSquareByPos(endPos);\n\n    //     if(!fromSquare || !toSquare) return false;\n\n    //     let pieceOnFromSquare: PieceModel | undefined = fromSquare.getPiece();\n    //     if(!pieceOnFromSquare) return false;\n\n    //     let pieceColor = pieceOnFromSquare.getColor();\n    //     if(pieceColor !== this.turn) return false;\n    //     if(this.checkmate(pieceColor)) return false;\n    //     if(this.castleMove(fromSquare,toSquare)) return true;\n    //     if(this.queeningMove(fromSquare,toSquare)) return true;\n    //     if(this.enPassant(fromSquare,toSquare)) return true;\n    //     if(!this.validMove(fromSquare,toSquare,pieceColor)) return false;\n\n    //     pieceOnFromSquare.beenMoved = true;\n    //     fromSquare.setPiece(undefined);\n    //     toSquare.setPiece(pieceOnFromSquare);\n    //     this.moveList.push({fromSquare:fromSquare.getPos(),toSquare:toSquare.getPos()});\n    //     this.changeTurn();\n    //     return true;\n    // }\n    // public checkmate(pieceColor:PlayerColor){\n    //     const search = this.searchBoardForPiece(PieceType.KING,pieceColor);\n    //     const king = search.piece as KingModel;\n    //     const kingPos = search.pos;\n    //     if(!king || !kingPos) return false;\n    //     if(!king.kingInCheck(this,kingPos)) return false;\n    // }\n    // public validMove(startSquare:SquareModel, endSquare:SquareModel, playerColor:PlayerColor){\n    //     const pieceMove = startSquare.getPiece();\n    //     if(pieceMove &&\n    //        pieceMove.validMove(this,startSquare,endSquare,playerColor)){\n    //        return true;\n    //     }\n    //     return false;\n    // }\n\n    // public castleMove(startSquare:SquareModel, endSquare:SquareModel){\n    //     const king = startSquare.getPiece() as KingModel;\n    //     let rookSquare = null;\n    //     let newRookSquare = null;\n    //     const endSquarePos = endSquare.getPos();\n\n    //     if(!king || king.getType() !== PieceType.KING) return false;\n    //     if(king.beenMoved) return false;\n    //     if( endSquarePos !== \"c1\" && endSquarePos !== \"g1\" &&\n    //         endSquarePos !== \"c8\" && endSquarePos !== \"g8\") return false;\n    //     const kingColor = king.getColor();\n    //     const row = kingColor === PlayerColor.WHITE? 7:0;\n\n    //     if(endSquarePos.charAt(0) === \"g\"){\n    //         rookSquare = this.chessBoard[row][7];\n    //         if( this.chessBoard[row][6].getPiece() || king.kingInCheck(this,this.chessBoard[row][6].getPos())||\n    //             this.chessBoard[row][5].getPiece() || king.kingInCheck(this,this.chessBoard[row][5].getPos())\n    //         ) return false;\n    //         newRookSquare = this.chessBoard[row][5];\n    //     }\n    //     else{\n    //         rookSquare = this.chessBoard[row][0]; \n    //         if( this.chessBoard[row][3].getPiece() || king.kingInCheck(this,this.chessBoard[row][3].getPos())||\n    //             this.chessBoard[row][2].getPiece() || king.kingInCheck(this,this.chessBoard[row][2].getPos())||\n    //             this.chessBoard[row][1].getPiece() || king.kingInCheck(this,this.chessBoard[row][1].getPos())\n    //         ) return false;\n    //         newRookSquare = this.chessBoard[row][3];\n    //     }\n    //     const rook = rookSquare.getPiece();\n    //     if(!rook || rook.getType() !== PieceType.ROOK) return false;\n    //     if(rook.beenMoved) return false;\n\n    //     rookSquare.setPiece(undefined);\n    //     startSquare.setPiece(undefined);\n    //     newRookSquare.setPiece(rook);\n    //     endSquare.setPiece(king);\n    //     king.beenMoved = true;\n    //     rook.beenMoved = true;\n    //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //     this.changeTurn();\n    //     return true;\n    // }\n    // private queeningMove(startSquare:SquareModel, endSquare:SquareModel){\n    //     const pawn = startSquare.getPiece();\n    //     const endSquarePos = this.posToArrayPos(endSquare.getPos());\n    //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n    //     if(!endSquarePos) return false;\n        \n    //     const pawnColor = pawn.getColor();\n    //     let endRow = pawnColor === PlayerColor.WHITE? 0:7;\n    //     let endSquareRow = endSquarePos.i;\n        \n    //     if(pawnColor===PlayerColor.WHITE && endSquareRow!==endRow) return false;\n    //     else if(pawnColor===PlayerColor.BLACK && endSquareRow!==endRow) return false;\n\n    //     startSquare.setPiece(undefined);\n    //     endSquare.setPiece(new QueenModel(PieceType.QUEEN,pawnColor));\n    //     this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //     this.changeTurn();\n    //     return true;\n    // }\n    // private enPassant(startSquare:SquareModel, endSquare:SquareModel){\n    //     const board = this.chessBoard;\n    //     const pawn = startSquare.getPiece();\n    //     const startSquarePos = this.posToArrayPos(startSquare.getPos());\n    //     if(this.moveList.length === 0) return false;\n\n    //     const lastMove = this.getMoveList().slice(-1)[0];\n    //     const pieceLastMovedNewPos = this.posToArrayPos(lastMove.toSquare);\n    //     const pieceLastMovedOldPos = this.posToArrayPos(lastMove.fromSquare);\n\n    //     if(!pawn || pawn.getType() !== PieceType.PAWN) return false;\n    //     if(!startSquarePos) return false;\n    //     if(!pieceLastMovedNewPos || !pieceLastMovedOldPos) return false;\n\n    //     let direction = PawnModel.pawnDirections(pawn.getColor());\n        \n    //     const pieceLastMoved = board[pieceLastMovedNewPos.i][pieceLastMovedNewPos.j];\n\n    //     let pieceLeft;\n    //     let pieceRight;\n    //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j-1)){\n    //         pieceLeft = board[startSquarePos.i][startSquarePos.j-1];\n    //     }\n    //     if(ChessBoardModel.withinBoard(startSquarePos.i,startSquarePos.j+1)){\n    //         pieceRight = board[startSquarePos.i][startSquarePos.j+1];\n    //     }\n    //     let pieceLeftTakes = board[startSquarePos.i+direction.takes.left.dy][startSquarePos.j+direction.takes.left.dx];\n    //     let pieceRightTakes = board[startSquarePos.i+direction.takes.right.dy][startSquarePos.j+direction.takes.right.dx];\n    //     let pieceLastMovedDx = Math.abs(pieceLastMovedNewPos.j-pieceLastMovedOldPos.j);\n    //     let pieceLastMovedDy = Math.abs(pieceLastMovedNewPos.i-pieceLastMovedOldPos.i);\n    //     if(pieceLastMoved === pieceLeft && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceLeftTakes){\n    //         startSquare.setPiece(undefined);\n    //         pieceLeft.setPiece(undefined);\n    //         pieceLeftTakes.setPiece(pawn);\n    //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //         this.changeTurn();\n    //         return true;\n    //     }\n    //     if(pieceLastMoved === pieceRight && pieceLastMovedDx===0 && pieceLastMovedDy===2 && endSquare === pieceRightTakes){\n    //         startSquare.setPiece(undefined);\n    //         pieceRight.setPiece(undefined);\n    //         pieceRightTakes.setPiece(pawn);\n    //         this.moveList.push({fromSquare:startSquare.getPos(),toSquare:endSquare.getPos()});\n    //         this.changeTurn();\n    //         return true;\n    //     }\n    //     return false;\n    // }\n    // public isKingInCheck(kingColor:PlayerColor): boolean {\n    //     const kingLocation = this.searchBoardForPiece(PieceType.KING, kingColor)\n    //     const kingPos = kingLocation.pos;\n    //     if(!kingPos) return false;\n\n    //     const king = kingLocation.piece as KingModel;\n    //     if(!king) return false;\n\n    //     return king.kingInCheck(this,kingPos);\n    // }\n    // public searchBoardForPiece(pieceType:PieceType,pieceColor:PlayerColor):{pos:string | undefined, piece:PieceModel | undefined}{\n    //     for(let row of this.chessBoard){\n    //         for(let square of row){\n    //             const piece = square.getPiece();\n    //             if(piece && \n    //                piece.getType() === pieceType &&\n    //                piece.getColor() === pieceColor\n    //                ) return {pos: square.getPos(), piece: piece};\n    //         }\n    //     }\n    //     return {pos:undefined, piece:undefined};\n    // }\n    public searchBoardFromPos(ignorePiece:PieceModel,startPos:string, directions:Object, pieceType:PieceType, callback:Function){\n        const board = this.getChessBoard();\n        const posArray = this.posToArrayPos(startPos);\n        if(!posArray) return false;\n\n        for(const [,value] of Object.entries(directions)){\n            let i = posArray.i;\n            let j = posArray.j;\n\n            let result = callback(board,ignorePiece,i,j,value,pieceType);\n            if(result) return true;\n        }\n\n        return false;\n    }\n    public findPiece(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n        i += direction.dy;\n        j += direction.dx;\n        if(ChessBoardModel.withinBoard(i,j)){\n            const currentPiece = board[i][j].getPiece();\n            if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n                if( currentPiece.getType() === pieceType ){\n                        return true;\n                }\n                else{\n                    return false;\n                }\n            }else if( currentPiece && \n                        currentPiece.getColor() === ignorePiece.getColor() &&\n                        currentPiece !== ignorePiece){\n                return false;\n            }\n        }\n        return false;\n    }\n    public findPieceInDirection(board: Array<Array<SquareModel>>,ignorePiece:PieceModel,i:number,j:number,direction:{dx:number,dy:number}, pieceType:PieceType){\n        let flag = true;\n        while(flag){\n            i += direction.dy;\n            j += direction.dx;\n\n\n            if(ChessBoardModel.withinBoard(i,j)){\n                const currentPiece = board[i][j].getPiece();\n                if(currentPiece && currentPiece.getColor() !== ignorePiece.getColor()){\n                    if( currentPiece.getType() === pieceType){\n                            return true;\n                    }\n                    else{\n                        flag = false;\n                    }\n                }else if( currentPiece && \n                            currentPiece.getColor() === ignorePiece.getColor() &&\n                            currentPiece !== ignorePiece){\n                    flag = false;\n                }\n            }\n            else flag = false;\n        }       \n        return false;  \n    }\n    public findPawnAttack(ignorePiece:PieceModel,kingPos:string){\n        let pawnDirection = PawnModel.pawnDirections(ignorePiece.getColor());\n        const posArray = this.posToArrayPos(kingPos);\n        if(!posArray) return false;\n        let leftTakes = pawnDirection.takes.left;\n        let rightTakes = pawnDirection.takes.right;\n\n        return this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,leftTakes,PieceType.PAWN) ||\n               this.findPiece(this.chessBoard,ignorePiece,posArray.i,posArray.j,rightTakes,PieceType.PAWN)\n    }\n    public getChessBoard():Array<Array<SquareModel>>{\n        return this.chessBoard;\n    }\n    public getMoveList(){\n        return this.moveList;\n    }\n    public getPosMap():Map<string,{i:number,j:number}>{\n        return this.posMap;\n    }\n    public posToArrayPos(pos: string){\n        return this.posMap.get(pos);\n    }\n\n    public getSquareByPos(pos: string){\n        let arrayPos = this.posMap.get(pos);\n        if(!arrayPos) return null;\n\n        let iPos = arrayPos.i;\n        let jPos = arrayPos.j;\n        const square = this.chessBoard[iPos][jPos];\n        if(!square) return null;\n\n        return square;\n    }\n    public static withinBoard(i:number, j:number){\n        return i>=0 &&\n               i<BOARD_SIZE &&\n               j>=0 &&\n               j<BOARD_SIZE;\n    }\n    private changeTurn() {\n        this.turn = this.turn === PlayerColor.WHITE?\n            PlayerColor.BLACK:\n            PlayerColor.WHITE;\n    }\n\n    private initBoard(){\n        let col = ROW_VALUES;\n        let row = [...COL_VALUES].reverse();\n        let k = 0, n = 0;\n        for(let i = 0; i< BOARD_SIZE; i++){\n            for(let j = 0; j< BOARD_SIZE; j++){\n\n                let pos:string = col[j]+row[i];\n                this.posMap.set(pos,{i:i, j:j});\n                let color = (j+i+2) % 2 === 0? PlayerColor.WHITE:PlayerColor.BLACK;\n                //let piece:PieceModel | undefined = this.genPiece(col[j],row[i]);\n                \n                if(i===0 || i===1){\n                    this.chessBoard[i].push(\n                        new SquareModel(color,pos,this.blackPieces[k])\n                    );\n                    k++;\n                }\n                else if(i===6 || i===7){\n                    this.chessBoard[i].push(\n                        new SquareModel(color,pos,this.whitePieces[n])\n                    );\n                    n++;\n                }\n                else{\n                    this.chessBoard[i].push(\n                        new SquareModel(color,pos)\n                    );\n                }\n                // if(piece){\n                //     this.chessBoard[i].push(\n                //         new SquareModel(color,pos,piece)\n                //     );\n                // }else{\n                //     this.chessBoard[i].push(\n                //         new SquareModel(color,pos)\n                //     );\n                // }\n            }\n        }\n    }\n    // private genPiece(col:string,row:number): PieceModel | undefined{\n    //     if(row === 2){\n    //         return new PawnModel(PieceType.PAWN,PlayerColor.WHITE);\n    //     }\n    //     else if(row === 7){\n    //         return new PawnModel(PieceType.PAWN,PlayerColor.BLACK);\n    //     }\n    //     else if(row === 1){\n    //         if(col === 'a' || col === 'h'){\n    //             return new RookModel(PieceType.ROOK,PlayerColor.WHITE);\n    //         }\n    //         else if(col=== 'b' || col === 'g'){\n    //             return new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE);\n    //         }\n    //         else if(col=== 'c' || col === 'f'){\n    //             return new BishopModel(PieceType.BISHOP, PlayerColor.WHITE);\n    //         }\n    //         else if(col === 'd'){\n    //             return new QueenModel(PieceType.QUEEN, PlayerColor.WHITE);\n    //         }\n    //         else{\n    //             return new KingModel(PieceType.KING, PlayerColor.WHITE);\n    //         }\n    //     }\n    //     else if(row === 8){\n    //         if(col === 'a' || col === 'h'){\n    //             return new RookModel(PieceType.ROOK,PlayerColor.BLACK);\n    //         }\n    //         else if(col=== 'b' || col === 'g'){\n    //             return new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK);\n    //         }\n    //         else if(col=== 'c' || col ==='f'){\n    //             return new BishopModel(PieceType.BISHOP, PlayerColor.BLACK);\n    //         }\n    //         else if(col === 'd'){\n    //             return new QueenModel(PieceType.QUEEN, PlayerColor.BLACK);\n    //         }\n    //         else{\n    //             return new KingModel(PieceType.KING, PlayerColor.BLACK);\n    //         }\n    //     }\n    //     else{\n    //         return undefined;\n    //     }\n    // }\n\n    public clone():ChessBoardModel{\n        const clone =Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n        clone.chessBoard = this.chessBoard.map((row) =>\n            row.map((square) => {\n            const clonedSquare = new SquareModel(square.getColor(), square.getPos());\n            const piece = square.getPiece();\n            if (piece) {\n                const clonedPiece = Object.assign(Object.create(Object.getPrototypeOf(piece)), piece)\n                clonedSquare.setPiece(clonedPiece);\n            }\n            return clonedSquare;\n            })\n        );\n\n        clone.posMap = new Map(this.posMap);\n        return clone;\n    }\n}\n//  const whitePieces = [\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new PawnModel(PieceType.PAWN,PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.WHITE),\n//     new KingModel(PieceType.KING, PlayerColor.WHITE),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.WHITE),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.WHITE),\n//     new RookModel(PieceType.ROOK,PlayerColor.WHITE)\n// ];\n\n//  const blackPieces = [\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new QueenModel(PieceType.QUEEN, PlayerColor.BLACK),\n//     new KingModel(PieceType.KING, PlayerColor.BLACK),\n//     new BishopModel(PieceType.BISHOP, PlayerColor.BLACK),\n//     new KnightModel(PieceType.KNIGHT, PlayerColor.BLACK),\n//     new RookModel(PieceType.ROOK,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK),\n//     new PawnModel(PieceType.PAWN,PlayerColor.BLACK)\n// ];"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}